{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red8\green18\blue45;\red255\green255\blue255;\red203\green203\blue202;
\red8\green18\blue45;\red203\green203\blue202;\red232\green232\blue231;\red194\green194\blue194;\red39\green130\blue201;
\red255\green255\blue255;\red235\green16\blue47;\red213\green20\blue102;\red255\green255\blue255;\red20\green152\blue108;
\red225\green130\blue14;\red8\green18\blue45;\red204\green204\blue202;\red108\green121\blue134;\red255\green255\blue255;
\red252\green95\blue162;\red93\green217\blue255;\red209\green168\blue255;\red65\green162\blue192;\red208\green191\blue105;
\red162\green103\blue230;\red162\green104\blue231;\red158\green241\blue221;\red158\green241\blue221;\red103\green183\blue164;
\red103\green183\blue164;\red209\green169\blue255;\red252\green106\blue93;\red146\green161\blue177;\red7\green18\blue45;
\red255\green255\blue255;\red203\green203\blue202;}
{\*\expandedcolortbl;;\cssrgb\c2298\c9773\c23298;\cssrgb\c100000\c100000\c100000\c0;\cssrgb\c83502\c83501\c83084;
\cssrgb\c2298\c9773\c23298;\cssrgb\c83502\c83501\c83084;\cssrgb\c92651\c92651\c92535;\cssrgb\c80481\c80481\c80380;\cssrgb\c18263\c58706\c82998;
\cssrgb\c100000\c100000\c99985;\cssrgb\c94794\c17090\c23647;\cssrgb\c87485\c18826\c47379;\cssrgb\c100000\c100000\c99985\c50196;\cssrgb\c722\c65207\c49761;
\cssrgb\c91120\c58108\c4269;\cssrgb\c2388\c9880\c23402;\cssrgb\c83591\c83590\c83069;\cssrgb\c49894\c54999\c59642;\cssrgb\c100000\c100000\c99985\c85000;
\cssrgb\c100000\c47839\c69704;\cssrgb\c42156\c87689\c100000;\cssrgb\c85689\c73149\c100000;\cssrgb\c30856\c69315\c80002;\cssrgb\c85014\c78708\c48407;
\cssrgb\c70040\c50841\c92347;\cssrgb\c69952\c50995\c92413;\cssrgb\c67458\c94923\c89343;\cssrgb\c67281\c95012\c89217;\cssrgb\c47068\c76104\c70157;
\cssrgb\c46914\c76156\c70251;\cssrgb\c85590\c73304\c100000;\cssrgb\c99989\c50531\c43740;\cssrgb\c63918\c69435\c74792;\cssrgb\c2208\c9666\c23194;
\cssrgb\c100000\c100000\c99985\c0;\cssrgb\c83411\c83411\c83099;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}}
\margl1440\margr1440\vieww13540\viewh13000\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 	\cf5 \outl0\strokewidth0 I want to add texture support to my SwiftUI, MetalKit shader program, but I\'92m not ready.  Before I add texture support, I want to refactor my code to better separate and encapsulate related functionality into separate classes.\
\pard\pardeftab720\partightenfactor0
\cf5 \
I currently have a render manager, a uniform manager, and a metal view. The intent is that the render manager be the coordinator/orchestrator for managing the various components necessary to set up an manage the rendering of a shader file. the metal view is intended to do all the configuration and set up of the metal rendering pipelines needed to render a shader.  the uniform manager is responsible for keeping a dynamic memory store of all of the uniforms and values that are sent to the shader to buffer, by the metal view.  Right now, some things in the metal view should be handled in the render manager. Some things are redundant, such as the uniform manager and the metal view both opening the shader source for different reasons. As I developed the application, I was quick to get things working, and did not always take care to keep state management and related logic separated between the render manager and the metal view.  Rather than passing state top down from the render manager to the metal view, the metal view inspects state in the render manager as each has a reference to the other. this is brittle and confusing.  Also, If either encounters an error, the coordination of error handling is indirect and hard to understand, even though it works.  Basically, the render manager should maintain the configuration state of the current rendering set up, leaving each subcomponent to track its own necessary state for operation.\
\
It would be best to extract all shader file handling and processing logic into a separate class called the shader manager.\
I want to load the pre-processed (using `cpp` in a shell exec) shader file one time and do the scanning for uniform definitions, files to monitor for change, and (eventually) texture declarations with the pre-processer\'92s output.  If no errors are encountered during that phase, then the source file should be compiled into .metallib binary format, and the binary\'92s URL should be passed to the metal view for loading.  An error can occur at any stage.  the shader manager would first pre-process the shader file, then scan it for files to monitor, then scan it for uniform definitions, then compile it into a metal binary. The render manager would call the shader manager anytime the user chooses a different shader file, or any of the opened shader files are updated. If the shader manager is successful at opening, pre-processing, scanning, and compiling the shader of file, it will return a value of true to the render manager. the render manager can then access the files to be monitored, the uniforms to be defined, and the URL of the metal binary to pass to the metal view for loading into a library. if an error occurs at any stage, the shader manager will store an error, message, and return false to the render manager.  assuming the shader manager succeeds, the render manager will pass the metal binary URL to the metal view for loading, by calling a load shader method on the metal view.  the load shader method on metal view will accept a URL and attempt to load the binary metal shader file into a library and extract the shader functions it needs.  If an error occurs during this process, the metal view will store an error message and return false to the render manager.  the library successfully created from the metal binary file and the fragment shader functions are found, it will return true to the render manager.\
\
The render manager should be the primary coordinator or controller for all of the render related classes. It is also responsible for communicating with the swift UI view. It is instantiated by the application.\
\
Rather than have the OSC server in the uniform manager, there should be one single OSC server for the entire application. That single server will listen for OSC messages for the entire application. It can then delegate received messages to the render manager, which can decide which messages to send to the uniform manager. I want to define a delegate pattern to be shared by any class that will receive OSC messages.\
\
The metal view will handle all and only the metal specific functionality for rendering.  Any functionality not related specifically to rendering to the metal framework, should be extracted into the render manager.\
\pard\pardeftab720\partightenfactor0
\cf2 \outl0\strokewidth0 \strokec4 \
\pard\pardeftab720\sa160\partightenfactor0

\f1\fs40 \cf7 \outl0\strokewidth0 1. Create a ShaderManager Class\
\pard\pardeftab720\sa400\partightenfactor0

\fs32 \cf7 Responsibilities:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf7 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cf7 \expnd0\expndtw0\kerning0
Pre-processing: Use 
\fs28 \cf7 cpp
\fs32 \cf7  to pre-process the shader file. Handle any errors that occur and store meaningful error messages.\
\ls1\ilvl0\cf7 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cf7 \expnd0\expndtw0\kerning0
Scanning: Extract uniform definitions and monitorable file paths from the shader\'92s pre-processed output.\
\ls1\ilvl0\cf7 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cf7 \expnd0\expndtw0\kerning0
Compiling: Compile the shader into a 
\fs28 \cf7 .metallib
\fs32 \cf7  file. Capture the output URL and handle any compilation errors.\
\pard\pardeftab720\sa400\partightenfactor0
\cf7 Code Structure:	\
\pard\pardeftab720\partightenfactor0

\fs24 \cf8 swift\
\pard\pardeftab720\qc\partightenfactor0
\cf8 \
\pard\pardeftab720\partightenfactor0
\cf8 Copy code\
\pard\pardeftab720\partightenfactor0

\fs28 \cf9 class\cf7  \cf11 ShaderManager\cf7  \{\
    \cf9 var\cf7  metallibURL: \cf12 URL\cf7 ?\
    \cf9 var\cf7  uniforms: [\cf12 String\cf7 : \cf9 Any\cf7 ] \cf13 // Define as per your data needs\cf7 \
    \cf9 var\cf7  filesToMonitor: [\cf12 URL\cf7 ]\
    \cf9 var\cf7  errorMessage: \cf12 String\cf7 ?\
\
    \cf9 func\cf7  \cf11 processShader\cf7 (fileURL: \cf12 URL\cf7 ) -> \cf12 Bool\cf7  \{\
        \cf9 do\cf7  \{\
            \cf13 // Preprocess, scan, and compile\cf7 \
            \cf13 // Update `metallibURL`, `uniforms`, `filesToMonitor`\cf7 \
            \cf9 return\cf7  \cf9 true\cf7 \
        \} \cf9 catch\cf7  \{\
            errorMessage = \cf14 "An error occurred: \\(error.localizedDescription)"\cf7 \
            \cf9 return\cf7  \cf9 false\cf7 \
        \}\
    \}\
\}\
\pard\pardeftab720\sa160\partightenfactor0

\fs40 \cf7 2. Update RenderManager\
\pard\pardeftab720\sa400\partightenfactor0

\fs32 \cf7 Responsibilities:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0\cf7 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cf7 \expnd0\expndtw0\kerning0
Acts as the central coordinator between the UI, ShaderManager, and MetalView.\
\ls2\ilvl0\cf7 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cf7 \expnd0\expndtw0\kerning0
Handles the delegation of OSC messages through a defined protocol.\
\pard\pardeftab720\sa400\partightenfactor0
\cf7 Code Snippet:\
\pard\pardeftab720\partightenfactor0

\fs24 \cf8 swift\
\pard\pardeftab720\qc\partightenfactor0
\cf8 \
\pard\pardeftab720\partightenfactor0
\cf8 Copy code\
\pard\pardeftab720\partightenfactor0

\fs28 \cf9 protocol\cf7  \cf11 OSCMessageDelegate\cf7  \{\
    \cf9 func\cf7  \cf11 handleOSCMessage\cf7 (message: \cf12 OSCMessage\cf7 )\
\}\
\
\cf9 class\cf7  \cf11 RenderManager\cf7 : \cf11 OSCMessageDelegate\cf7  \{\
    \cf9 var\cf7  shaderManager: \cf12 ShaderManager\cf7 ?\
    \cf9 var\cf7  metalView: \cf12 MetalView\cf7 ?\
    \cf9 var\cf7  oscServer: \cf12 OSCServer\cf7 ?\
\
    \cf9 func\cf7  \cf11 handleOSCMessage\cf7 (message: \cf12 OSCMessage\cf7 ) \{\
        \cf13 // Implement how to handle the received OSC message\cf7 \
    \}\
\
    \cf9 func\cf7  \cf11 changeShader\cf7 (fileURL: \cf12 URL\cf7 ) \{\
        \cf9 guard\cf7  shaderManager?.processShader(fileURL: fileURL) == \cf9 true\cf7  \cf9 else\cf7  \{\
            \cf15 print\cf7 (\cf14 "Failed to process shader: \\(shaderManager?.errorMessage ?? "Unknown error")"\cf7 )\
            \cf9 return\cf7 \
        \}\
        metalView?.loadShader(from: shaderManager!.metallibURL!)\
    \}\
\}\
\pard\pardeftab720\sa160\partightenfactor0

\fs40 \cf7 3. Refactor MetalView\
\pard\pardeftab720\sa400\partightenfactor0

\fs32 \cf7 Responsibilities:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls3\ilvl0\cf7 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cf7 \expnd0\expndtw0\kerning0
Solely manages Metal-specific rendering operations.\
\ls3\ilvl0\cf7 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cf7 \expnd0\expndtw0\kerning0
Loads and configures Metal shader libraries and manages the GPU interface.\
\pard\pardeftab720\sa400\partightenfactor0
\cf7 Code Snippet:\
\pard\pardeftab720\partightenfactor0

\fs24 \cf8 swift\
\pard\pardeftab720\qc\partightenfactor0
\cf8 \
\pard\pardeftab720\partightenfactor0
\cf8 Copy code\
\pard\pardeftab720\partightenfactor0

\fs28 \cf9 class\cf7  \cf11 MetalView\cf7  \{\
    \cf9 var\cf7  device: \cf12 MTLDevice\cf7 ?\
    \cf9 var\cf7  library: \cf12 MTLLibrary\cf7 ?\
    \cf9 var\cf7  errorMessage: \cf12 String\cf7 ?\
\
    \cf9 func\cf7  \cf11 loadShader\cf7 (from url: \cf12 URL\cf7 ) -> \cf12 Bool\cf7  \{\
        \cf9 do\cf7  \{\
            library = \cf9 try\cf7  device?.makeLibrary(URL: url)\
            \cf13 // Further shader function extraction\cf7 \
            \cf9 return\cf7  \cf9 true\cf7 \
        \} \cf9 catch\cf7  \{\
            errorMessage = \cf14 "Failed to load shader: \\(error.localizedDescription)"\cf7 \
            \cf9 return\cf7  \cf9 false\cf7 \
        \}\
    \}\
\}\
\pard\pardeftab720\sa160\partightenfactor0

\fs40 \cf7 4. OSC Server Integration\
\pard\pardeftab720\sa400\partightenfactor0

\fs32 \cf7 Ensure that the OSC server is configured at a higher level, possibly in your AppDelegate or equivalent, and inject it into the RenderManager. This keeps the OSC handling centralized and decouples it from the rendering logic.\
\pard\pardeftab720\sa160\partightenfactor0

\fs40 \cf7 Final Considerations\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls4\ilvl0
\fs32 \cf7 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cf7 \expnd0\expndtw0\kerning0
Error Handling: Ensure that error handling is robust and that each component can report back to the RenderManager in a way that makes it easy to understand what went wrong.\
\ls4\ilvl0\cf7 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cf7 \expnd0\expndtw0\kerning0
Testing: Thoroughly test each component independently before integrating.\
\ls4\ilvl0\cf7 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cf7 \expnd0\expndtw0\kerning0
Documentation: Update your documentation to reflect the new architecture and how components interact.\
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf16 \outl0\strokewidth0 \strokec17 \
\cf2 \strokec4 \
Here is the code I currently have:\
\
\'97\
\
\pard\tx593\pardeftab593\partightenfactor0

\f2\fs24 \cf18 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 //\cf19 \
\cf18 //  RenderDataModel.swift\cf19 \
\cf18 //  MetalGemini\cf19 \
\cf18 //\cf19 \
\cf18 //  Created by Bill Doughty on 3/28/24.\cf19 \
\cf18 //\cf19 \
\

\f3\b \cf20 import
\f2\b0 \cf19  Foundation\

\f3\b \cf20 import
\f2\b0 \cf19  Cocoa\
\

\f3\b \cf20 class
\f2\b0 \cf19  \cf21 RenderManager\cf19 : \cf22 ObservableObject\cf19  \{\
    \cf22 @Published\cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 frameCount\cf19 : \cf22 UInt32\cf19  = \cf24 0\cf19 \
    \cf22 @Published\cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 lastFrame\cf19 : \cf22 UInt32\cf19  = \cf24 0\cf19 \
    \cf22 @Published\cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 fps\cf19 : \cf22 Double\cf19  = \cf24 0\cf19 \
    \cf22 @Published\cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 lastTime\cf19 : \cf22 TimeInterval\cf19  = \cf22 Date\cf19 ().\cf25 timeIntervalSince1970\cf19 \
    \cf22 @Published\cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 selectedFile\cf19 : \cf22 URL\cf19 ? = 
\f3\b \cf20 nil
\f2\b0 \cf19 \
    \cf22 @Published\cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 openFileDialog\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 \
    \cf22 @Published\cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 title\cf19 : \cf22 String\cf19 ? = 
\f3\b \cf20 nil
\f2\b0 \cf19 \
    \cf22 @Published\cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 shaderError\cf19 : \cf22 String\cf19 ? = 
\f3\b \cf20 nil
\f2\b0 \cf19 \
\
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 reloadShaders\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 size\cf19 : \cf22 CGSize\cf19  = \cf22 CGSize\cf19 (\cf26 width\cf19 :\cf24 0\cf19 ,\cf26 height\cf19 :\cf24 0\cf19 )\
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 fileDescriptors\cf19 : [\cf22 Int32\cf19 ] = []\
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 shaderURLs\cf19 : [\cf22 URL\cf19 ] = []\
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 fileMonitorSources\cf19 : [DispatchSourceFileSystemObject] = []\
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 coordinator\cf19 : \cf27 MetalView\cf19 .\cf28 Coordinator\cf19 ?\
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 startDate\cf19  = \cf22 Date\cf19 ()\
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 uniformManager\cf19  = \cf28 UniformManager\cf19 ()\
    
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 pauseTime\cf19  = \cf22 Date\cf19 ()\
\
    
\f3\b \cf20 init
\f2\b0 \cf19 () \{\
    \}\
    \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 vsyncOn\cf19 : \cf22 Bool\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19  \{\
        
\f3\b \cf20 didSet
\f2\b0 \cf19  \{\
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 coordinator\cf19 ?.\cf30 updateVSyncState\cf19 (
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 vsyncOn\cf19 )\
            \cf31 NotificationCenter\cf19 .\cf25 default\cf19 .\cf26 post\cf19 (\cf26 name\cf19 : .\cf29 vsyncStatusDidChange\cf19 , \cf26 object\cf19 : 
\f3\b \cf20 nil
\f2\b0 \cf19 , \cf26 userInfo\cf19 : [\cf32 "enabled"\cf19 : \cf29 vsyncOn\cf19 ])\
        \}\
    \}\
\
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 renderingPaused\cf19 : \cf22 Bool\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19  \{\
        
\f3\b \cf20 didSet
\f2\b0 \cf19  \{\
            
\f3\b \cf20 if
\f2\b0 \cf19  \cf29 renderingPaused\cf19  \{\
                \cf29 pauseTime\cf19  = \cf22 Date\cf19 ()\
                \cf29 coordinator\cf19 ?.\cf30 stopRendering\cf19 ()\
            \} 
\f3\b \cf20 else
\f2\b0 \cf19  \{\
                \cf29 startDate\cf19  += \cf22 Date\cf19 ().\cf26 timeIntervalSince\cf19 (\cf29 pauseTime\cf19 )\
                \cf29 coordinator\cf19 ?.\cf30 startRendering\cf19 ()\
            \}\
            \cf30 updateTitle\cf19 ()\
        \}\
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 updateTitle\cf19 () \{\
        
\f3\b \cf20 let
\f2\b0 \cf19  file = \cf32 "\cf19 \\(\cf29 selectedFile\cf19 ?.\cf25 lastPathComponent\cf19  ?? \cf32 "<no file>"\cf19 )\cf32 "\cf19 \
        
\f3\b \cf20 let
\f2\b0 \cf19  size = \cf22 String\cf19 (\cf26 format\cf19 : \cf32 "%.0fx%.0f"\cf19 , \cf29 size\cf19 .\cf25 width\cf19 , \cf29 size\cf19 .\cf25 height\cf19 )\
        
\f3\b \cf20 var
\f2\b0 \cf19  fps = \cf22 String\cf19 (\cf26 format\cf19 : \cf32 "FPS: %.0f"\cf19 , \cf29 fps\cf19 )\
        
\f3\b \cf20 if
\f2\b0 \cf19  \cf29 renderingPaused\cf19  \{\
            fps = \cf32 "<PAUSED>"\cf19 \
        \} 
\f3\b \cf20 else
\f2\b0 \cf19  \{\
            \cf29 pauseTime\cf19  = \cf22 Date\cf19 ()\
        \}\
        
\f3\b \cf20 let
\f2\b0 \cf19  elapsedTime = \cf29 pauseTime\cf19 .\cf26 timeIntervalSince\cf19 (\cf29 startDate\cf19 );\
\
        \cf29 title\cf19  = \cf32 "\cf19 \\(file)\cf32  - \cf19 \\(size)\cf32  - \cf19 \\(fps)\cf32  - \cf19 \\(elapsedTime.\cf30 formattedMMSS\cf19 ())\cf32 "\cf19 \
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 resetFrame\cf19 () \{\
        DispatchQueue.\cf25 main\cf19 .\cf26 async\cf19  \{\
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 startDate\cf19  = \cf22 Date\cf19 ()\
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 frameCount\cf19  = \cf24 0\cf19 \
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 lastFrame\cf19  = \cf24 0\cf19 \
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 fps\cf19  = \cf24 0\cf19 \
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 lastTime\cf19  = \cf22 Date\cf19 ().\cf25 timeIntervalSince1970\cf19 \
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf30 updateTitle\cf19 ()\
        \}\
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 monitorShaderFiles\cf19 () \{\
        
\f3\b \cf20 for
\f2\b0 \cf19  fileDescriptor 
\f3\b \cf20 in
\f2\b0 \cf19  \cf29 fileDescriptors\cf19  \{\
            
\f3\b \cf20 if
\f2\b0 \cf19  fileDescriptor != -\cf24 1\cf19  \{\
                \cf26 close\cf19 (fileDescriptor)\
            \}\
        \}\
        \cf29 fileDescriptors\cf19 .\cf26 removeAll\cf19 ()\
\
        
\f3\b \cf20 for
\f2\b0 \cf19  shaderURL 
\f3\b \cf20 in
\f2\b0 \cf19  \cf29 shaderURLs\cf19  \{\
            
\f3\b \cf20 let
\f2\b0 \cf19  fileDescriptor = \cf26 open\cf19 (shaderURL.\cf25 path\cf19 , \cf25 O_EVTONLY\cf19 )\
            
\f3\b \cf20 if
\f2\b0 \cf19  fileDescriptor == -\cf24 1\cf19  \{\
                \cf26 print\cf19 (\cf32 "Unable to open file: \cf19 \\(shaderURL)\cf32 "\cf19 )\
                
\f3\b \cf20 return
\f2\b0 \cf19 \
            \}\
            \cf29 fileDescriptors\cf19 .\cf26 append\cf19 (fileDescriptor)\
        \}\
\
        
\f3\b \cf20 for
\f2\b0 \cf19  fileMonitorSource 
\f3\b \cf20 in
\f2\b0 \cf19  \cf29 fileMonitorSources\cf19  \{\
            fileMonitorSource.\cf26 cancel\cf19 ()\
        \}\
        \cf29 fileMonitorSources\cf19 .\cf26 removeAll\cf19 ()\
\
        
\f3\b \cf20 for
\f2\b0 \cf19  fileDescriptor 
\f3\b \cf20 in
\f2\b0 \cf19  \cf29 fileDescriptors\cf19  \{\
            
\f3\b \cf20 let
\f2\b0 \cf19  fileMonitorSource = DispatchSource.\cf26 makeFileSystemObjectSource\cf19 (\cf26 fileDescriptor\cf19 : fileDescriptor, \cf26 eventMask\cf19 : .\cf25 write\cf19 , \cf26 queue\cf19 : DispatchQueue.\cf25 main\cf19 )\
            fileMonitorSource.\cf26 setEventHandler\cf19  \{\
                
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 shaderError\cf19  = 
\f3\b \cf20 nil
\f2\b0 \cf19 \
                
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 reloadShaders\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
            \}\
            fileMonitorSource.\cf26 resume\cf19 ()\
            \cf29 fileMonitorSources\cf19 .\cf26 append\cf19 (fileMonitorSource)\
        \}\
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 loadShaderFile\cf19 (\cf23 _\cf19  fileURL: \cf22 URL\cf19 ?) \{\
        
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  selectedURL = fileURL 
\f3\b \cf20 else
\f2\b0 \cf19  \{\
            \cf26 print\cf19 (\cf32 "Unable to set file: \cf19 \\(\cf22 String\cf19 (\cf26 describing\cf19 : fileURL))\cf32 "\cf19 )\
            
\f3\b \cf20 return
\f2\b0 \cf19 \
        \}\
\
        \cf29 shaderError\cf19  = 
\f3\b \cf20 nil
\f2\b0 \cf19 \
        \cf29 selectedFile\cf19  = selectedURL\
        \cf29 reloadShaders\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
\
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 rewind\cf19 () \{\
        \cf29 startDate\cf19  += \cf24 1\cf19 \
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 fforward\cf19 () \{\
        \cf29 startDate\cf19  -= \cf24 1\cf19 \
    \}\
\}\
\

\f3\b \cf20 extension
\f2\b0 \cf19  \cf21 RenderManager\cf19 : \cf28 KeyboardViewDelegate\cf19  \{\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 keyDownEvent\cf19 (\cf23 event\cf19 : \cf31 NSEvent\cf19 , \cf23 flags\cf19 : \cf31 NSEvent\cf19 .\cf22 ModifierFlags\cf19 ) \{\
        \cf18 //        if event.isARepeat \{ return \}\cf19 \
\
        
\f3\b \cf20 let
\f2\b0 \cf19  keyCode = event.\cf25 keyCode\cf19 \
        
\f3\b \cf20 switch
\f2\b0 \cf19  keyCode \{\
        
\f3\b \cf20 case
\f2\b0 \cf19  \cf24 49\cf19 :  \cf18 // Space bar\cf19 \
            
\f3\b \cf20 break
\f2\b0 \cf19 \
        
\f3\b \cf20 case
\f2\b0 \cf19  \cf24 125\cf19 : \cf18 // Down arrow\cf19 \
            \cf30 resetFrame\cf19 ()\
        
\f3\b \cf20 case
\f2\b0 \cf19  \cf24 126\cf19 : \cf18 // Up arrow\cf19 \
            \cf29 renderingPaused\cf19 .\cf26 toggle\cf19 ()\
        
\f3\b \cf20 case
\f2\b0 \cf19  \cf24 123\cf19 : \cf18 // Left arrow\cf19 \
            \cf30 rewind\cf19 ()\
        
\f3\b \cf20 case
\f2\b0 \cf19  \cf24 124\cf19 : \cf18 // Right arrow\cf19 \
            \cf30 fforward\cf19 ()\
        
\f3\b \cf20 default
\f2\b0 \cf19 :\
            
\f3\b \cf20 break
\f2\b0 \cf19  \cf18 // Do nothing for other key codes\cf19 \
        \}\
        
\f3\b \cf20 let
\f2\b0 \cf19  flags = event.\cf25 modifierFlags\cf19 .\cf26 intersection\cf19 (.\cf25 deviceIndependentFlagsMask\cf19 )\
\
        
\f3\b \cf20 var
\f2\b0 \cf19  modifiers = \cf32 ""\cf19 \
        
\f3\b \cf20 if
\f2\b0 \cf19  flags.\cf26 contains\cf19 (.\cf25 shift\cf19 ) \{ modifiers += \cf32 "Shift "\cf19  \}\
        
\f3\b \cf20 if
\f2\b0 \cf19  flags.\cf26 contains\cf19 (.\cf25 control\cf19 ) \{ modifiers += \cf32 "Control "\cf19  \}\
        
\f3\b \cf20 if
\f2\b0 \cf19  flags.\cf26 contains\cf19 (.\cf25 option\cf19 ) \{ modifiers += \cf32 "Option "\cf19  \}\
        
\f3\b \cf20 if
\f2\b0 \cf19  flags.\cf26 contains\cf19 (.\cf25 command\cf19 ) \{ modifiers += \cf32 "Command "\cf19  \}\
        
\f3\b \cf20 if
\f2\b0 \cf19  flags.\cf26 contains\cf19 (.\cf25 capsLock\cf19 ) \{ modifiers += \cf32 "Capslock "\cf19  \}\
        
\f3\b \cf20 if
\f2\b0 \cf19  flags.\cf26 contains\cf19 (.\cf25 function\cf19 ) \{ modifiers += \cf32 "Function "\cf19  \}\
        \cf26 print\cf19 (\cf32 "Current modifiers: \cf19 \\(modifiers)\cf32 "\cf19 )\
\
    \}\
\}\
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf16 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec17 \
-\
\
\pard\tx593\pardeftab593\partightenfactor0

\f2\fs24 \cf18 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 //\cf19 \
\cf18 //  MetalView.swift\cf19 \
\cf18 //  MetalGemini\cf19 \
\cf18 //\cf19 \
\cf18 //  Created by Gemini on 3/27/24.\cf19 \
\cf18 //\cf19 \
\

\f3\b \cf20 import
\f2\b0 \cf19  SwiftUI\

\f3\b \cf20 import
\f2\b0 \cf19  MetalKit\
\

\f3\b \cf20 struct
\f2\b0 \cf19  \cf21 ViewportSize\cf19  \{\
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 width\cf19 : \cf22 Float\cf19 \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 height\cf19 : \cf22 Float\cf19 \
\}\
\
\

\f3\b \cf20 public
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  \cf23 MAX_RENDER_BUFFERS\cf19  = \cf24 4\cf19 \
\
\
\cf18 // we need this to get access to the inner class of MetalView\cf19 \

\f3\b \cf20 typealias
\f2\b0 \cf19  \cf21 MetalViewCoordinator\cf19  = \cf27 MetalView\cf19 .\cf28 Coordinator\cf19 \
\cf18 // we need this because makeCoordinator gets called every time MetalView\cf19 \
\cf18 // is hidden, and if we don't reuse an existing coordinator, a new and gets created\cf19 \
\cf18 // which creates a new OSC server and starts ravaging the CPU\cf19 \

\f3\b \cf20 var
\f2\b0 \cf19  \cf23 existingCoordinator\cf19 : \cf27 MetalViewCoordinator\cf19 ?\
\

\f3\b \cf20 struct
\f2\b0 \cf19  \cf21 MetalView\cf19 : \cf31 NSViewRepresentable\cf19  \{\
    \cf22 @ObservedObject\cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 renderMgr\cf19 : \cf28 RenderManager\cf19  \cf18 // Reference the ObservableObject\cf19 \
    
\f3\b \cf20 let
\f2\b0 \cf19  \cf23 retinaEnabled\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 \
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 makeCoordinator\cf19 () -> \cf28 Coordinator\cf19  \{\
        
\f3\b \cf20 if
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  coordinator = \cf29 existingCoordinator\cf19  \{\
            
\f3\b \cf20 return
\f2\b0 \cf19  coordinator\
        \}\
        \cf29 existingCoordinator\cf19  = \cf28 Coordinator\cf19 (
\f3\b \cf20 self
\f2\b0 \cf19 , \cf30 renderMgr\cf19 : \cf29 renderMgr\cf19 )\
        
\f3\b \cf20 return
\f2\b0 \cf19  \cf29 existingCoordinator\cf19 !\
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 makeNSView\cf19 (\cf23 context\cf19 : \cf22 Context\cf19 ) -> \cf31 MTKView\cf19  \{\
        
\f3\b \cf20 let
\f2\b0 \cf19  mtkView = \cf31 MTKView\cf19 ()\
        mtkView.\cf25 delegate\cf19  = context.\cf25 coordinator\cf19 \
        mtkView.\cf25 preferredFramesPerSecond\cf19  = \cf24 60\cf19 \
\
        
\f3\b \cf20 if
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  metalDevice = \cf26 MTLCreateSystemDefaultDevice\cf19 () \{\
            mtkView.\cf25 device\cf19  = metalDevice\
        \}\
        mtkView.\cf25 framebufferOnly\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 \
        mtkView.\cf25 clearColor\cf19  = \cf22 MTLClearColor\cf19 (\cf26 red\cf19 : \cf24 0\cf19 , \cf26 green\cf19 : \cf24 0\cf19 , \cf26 blue\cf19 : \cf24 0\cf19 , \cf26 alpha\cf19 : \cf24 1\cf19 )\
        mtkView.\cf25 drawableSize\cf19  = mtkView.\cf25 frame\cf19 .\cf25 size\cf19 \
        mtkView.\cf25 autoResizeDrawable\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19   \cf18 // setting this to false requires updateNSView to update the view's drawableSize\cf19 \
        
\f3\b \cf20 return
\f2\b0 \cf19  mtkView\
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 updateNSView\cf19 (\cf23 _\cf19  mtkView: \cf31 MTKView\cf19 , \cf23 context\cf19 : \cf22 Context\cf19 ) \{\
        
\f3\b \cf20 if
\f2\b0 \cf19 ( !\cf29 retinaEnabled\cf19  ) \{\
            \cf18 // with mtkView.autoResizeDrawable = false, we have to do this\cf19 \
            \cf18 // also, this is also how we avoid retina x2 texture sizes, which we may not always want to do\cf19 \
            
\f3\b \cf20 if
\f2\b0 \cf19 ( mtkView.\cf25 frame\cf19 .\cf25 size\cf19  != mtkView.\cf25 drawableSize\cf19  ) \{\
                mtkView.\cf25 drawableSize\cf19  = mtkView.\cf25 frame\cf19 .\cf25 size\cf19 \
                \cf26 print\cf19 (\cf32 "updateNSView: mtkView.drawableSize resized: \cf19 \\(mtkView.\cf25 frame\cf19 .\cf25 size\cf19 )\cf32 "\cf19 )\
            \}\
        \}\
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 sizeThatFits\cf19 ( \cf23 _\cf19  proposal: \cf22 ProposedViewSize\cf19 ,\
                       \cf23 nsView\cf19 : 
\f3\b \cf20 Self
\f2\b0 \cf19 .NSViewType,\
                       \cf23 context\cf19 : 
\f3\b \cf20 Self
\f2\b0 \cf19 .\cf22 Context\cf19  ) -> \cf22 CGSize\cf19 ? \{\
        
\f3\b \cf20 return
\f2\b0 \cf19  
\f3\b \cf20 nil
\f2\b0 \cf19 \
    \}\
\
\
    
\f3\b \cf20 struct
\f2\b0 \cf19  \cf21 SysUniforms\cf19  \{\
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 vpSize\cf19 : \cf27 ViewportSize\cf19 \
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 frameCount\cf19 : \cf22 UInt32\cf19 \
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 timeInterval\cf19 : \cf22 Float\cf19 \
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 passNum\cf19 : \cf22 UInt32\cf19 \
    \}\
\
    
\f3\b \cf20 class
\f2\b0 \cf19  \cf21 Coordinator\cf19 : \cf31 NSObject\cf19 , \cf31 MTKViewDelegate\cf19  \{\
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 renderMgr\cf19 : \cf28 RenderManager\cf19 \
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 parent\cf19 : \cf27 MetalView\cf19 \
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 metalDevice\cf19 : \cf31 MTLDevice\cf19 !\
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 metalCommandQueue\cf19 : \cf31 MTLCommandQueue\cf19 !\
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 pipelineStates\cf19 : [\cf31 MTLRenderPipelineState\cf19 ]\
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 sysUniformBuffer\cf19 : \cf31 MTLBuffer\cf19 ?\
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 frameCounter\cf19 : \cf22 UInt32\cf19 \
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 renderBuffers\cf19 : [\cf31 MTLTexture\cf19 ?]\
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 numBuffers\cf19  = \cf24 0\cf19 \
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 renderTimer\cf19 : \cf31 Timer\cf19 ?\
        
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 renderingActive\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
        
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  \cf23 renderQueue\cf19  = DispatchQueue(\cf26 label\cf19 : \cf32 "com.yourapp.renderQueue"\cf19 )\
        
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 renderSemaphore\cf19  = DispatchSemaphore(value: \cf24 1\cf19 ) \cf18 // Allows 1 concurrent access\cf19 \
\
        
\f3\b \cf20 init
\f2\b0 \cf19 (\cf23 _\cf19  parent: \cf27 MetalView\cf19 , \cf23 renderMgr\cf19 : \cf28 RenderManager\cf19  ) \{\
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 parent\cf19  = parent\
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 frameCounter\cf19  = \cf24 0\cf19 \
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 renderBuffers\cf19  = []\
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 pipelineStates\cf19  = []\
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 renderMgr\cf19  = renderMgr\
            
\f3\b \cf20 super
\f2\b0 \cf19 .\cf26 init\cf19 ()\
            renderMgr.\cf29 coordinator\cf19  = 
\f3\b \cf20 self
\f2\b0 \cf19 \
\
            
\f3\b \cf20 if
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  metalDevice = \cf26 MTLCreateSystemDefaultDevice\cf19 () \{\
                
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 metalDevice\cf19  = metalDevice\
            \}\
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 metalCommandQueue\cf19  = \cf29 metalDevice\cf19 .\cf26 makeCommandQueue\cf19 ()!\
\
\
            \cf18 // Load the default shaders and create the pipeline states\cf19 \
            \cf30 setupShaders\cf19 (
\f3\b \cf20 nil
\f2\b0 \cf19 )\
            \cf30 createUniformBuffers\cf19 ()\
\
            \cf18 // must initialize render buffers\cf19 \
            \cf30 updateViewportSize\cf19 (\cf22 CGSize\cf19 (\cf26 width\cf19 :\cf24 2\cf19 ,\cf26 height\cf19 :\cf24 2\cf19 ))\
        \}\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 setupShaders\cf19 (\cf23 _\cf19  shaderFileURL: \cf22 URL\cf19 ?) \{\
            \cf30 stopRendering\cf19 () \cf18 // ensure offline rendering is disabled\cf19 \
\
            \cf29 numBuffers\cf19  = \cf24 0\cf19 \
            \cf29 pipelineStates\cf19 .\cf26 removeAll\cf19 ()\
\
            \cf18 // Load the default Metal library\cf19 \
            
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 var
\f2\b0 \cf19  library = \cf29 metalDevice\cf19 .\cf26 makeDefaultLibrary\cf19 () 
\f3\b \cf20 else
\f2\b0 \cf19  \{\
                \cf26 fatalError\cf19 (\cf32 "Could not load default Metal library"\cf19 )\
            \}\
            \cf18 // Load the default vertex shader\cf19 \
            
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  vertexFunction = library.\cf26 makeFunction\cf19 (\cf26 name\cf19 : \cf32 "vertexShader"\cf19 ) 
\f3\b \cf20 else
\f2\b0 \cf19  \{\
                \cf26 fatalError\cf19 (\cf32 "Could not find vertexShader function"\cf19 )\
            \}\
\
            
\f3\b \cf20 if
\f2\b0 \cf19 ( shaderFileURL != 
\f3\b \cf20 nil
\f2\b0 \cf19  ) \{\
                
\f3\b \cf20 let
\f2\b0 \cf19  fileURL = shaderFileURL!\
                
\f3\b \cf20 let
\f2\b0 \cf19  metalLibURL = fileURL.\cf26 deletingPathExtension\cf19 ().\cf26 appendingPathExtension\cf19 (\cf32 "metallib"\cf19 )\
                
\f3\b \cf20 do
\f2\b0 \cf19  \{\
                    
\f3\b \cf20 let
\f2\b0 \cf19  tryLibrary = 
\f3\b \cf20 try
\f2\b0 \cf19  \cf29 metalDevice\cf19 .\cf26 makeLibrary\cf19 (\cf26 URL\cf19 : metalLibURL)\
                    library = tryLibrary\
                    DispatchQueue.\cf25 main\cf19 .\cf26 async\cf19  \{\
                        
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 renderMgr\cf19 .\cf29 shaderError\cf19  = 
\f3\b \cf20 nil
\f2\b0 \cf19 \
                    \}\
\
                    \cf18 // detect any uniform metadata in the shader source\cf19 \
                    \cf29 renderMgr\cf19 .\cf29 uniformManager\cf19 .\cf30 resetMapping\cf19 ()\
                    
\f3\b \cf20 let
\f2\b0 \cf19  error = \cf29 renderMgr\cf19 .\cf29 uniformManager\cf19 .\cf30 setupUniformsFromShader\cf19 (\cf30 metalDevice\cf19 : \cf29 metalDevice\cf19 !, \cf30 srcURL\cf19 : fileURL)\
                    
\f3\b \cf20 if
\f2\b0 \cf19 ( error != 
\f3\b \cf20 nil
\f2\b0 \cf19  ) \{ 
\f3\b \cf20 throw
\f2\b0 \cf19  error! \}\
\cf18 //                    let appDelegate = NSApplication.shared.delegate as? AppDelegate\cf19 \
\cf18 //                    if let view_u = renderMgr.uniformManager.getUniformFloat4("u_resolution") \{\cf19 \
\cf18 //                        appDelegate?.resizeWindow?(CGFloat(view_u.x), CGFloat(view_u.y))\cf19 \
\cf18 //                    \}\cf19 \
                    \cf29 renderMgr\cf19 .\cf29 uniformManager\cf19 .\cf30 setUniformTuple\cf19 (\cf32 "u_resolution"\cf19 , \cf30 values\cf19 : [\cf22 Float\cf19 (\cf29 renderMgr\cf19 .\cf29 size\cf19 .\cf25 width\cf19 ), \cf22 Float\cf19 (\cf29 renderMgr\cf19 .\cf29 size\cf19 .\cf25 height\cf19 )],\
                        \cf30 suppressSave\cf19 : 
\f3\b \cf20 true
\f2\b0 \cf19 )\
                \} 
\f3\b \cf20 catch
\f2\b0 \cf19  \{\
                    \cf26 print\cf19 (\cf32 "Couldn't load shader library at \cf19 \\(metalLibURL)\cf32 \\n\cf19 \\(error)\cf32 "\cf19 )\
                    DispatchQueue.\cf25 main\cf19 .\cf26 async\cf19  \{\
                        
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 renderMgr\cf19 .\cf29 shaderError\cf19  = \cf32 "\cf19 \\(error)\cf32 "\cf19 \
                    \}\
                    
\f3\b \cf20 return
\f2\b0 \cf19 \
                \}\
            \}\
\
            
\f3\b \cf20 var
\f2\b0 \cf19  fragmentFunctions: [\cf31 MTLFunction\cf19 ] = []\
\
            
\f3\b \cf20 do
\f2\b0 \cf19  \{\
                
\f3\b \cf20 for
\f2\b0 \cf19  i 
\f3\b \cf20 in
\f2\b0 \cf19  \cf24 0\cf19 ...\cf29 MAX_RENDER_BUFFERS\cf19  \{\
\
                    
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  fragmentFunction = library.\cf26 makeFunction\cf19 (\cf26 name\cf19 : \cf32 "fragmentShader\cf19 \\(i)\cf32 "\cf19 ) 
\f3\b \cf20 else
\f2\b0 \cf19  \{\
                        \cf26 print\cf19 (\cf32 "Could not find fragmentShader\cf19 \\(i)\cf32 "\cf19 )\
                        \cf26 print\cf19 (\cf32 "Stopping search."\cf19 )\
                        
\f3\b \cf20 continue
\f2\b0 \cf19 \
                    \}\
                    fragmentFunctions.\cf26 append\cf19 (fragmentFunction)\
                \}\
                
\f3\b \cf20 if
\f2\b0 \cf19  fragmentFunctions.\cf25 count\cf19  < \cf24 1\cf19  \{\
                    DispatchQueue.\cf25 main\cf19 .\cf26 async\cf19  \{\
                        
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 renderMgr\cf19 .\cf29 shaderError\cf19  = \cf32 "Must have at least one fragment shader named `fragmentShader0`"\cf19 \
                    \}\
                    
\f3\b \cf20 return
\f2\b0 \cf19 \
                \}\
                \cf29 numBuffers\cf19  = fragmentFunctions.\cf25 count\cf19 -\cf24 1\cf19 \
                \cf26 print\cf19 (\cf32 "numBuffers: \cf19 \\(\cf29 numBuffers\cf19 )\cf32 "\cf19 )\
                \cf26 assert\cf19 (\cf29 numBuffers\cf19  >= \cf24 0\cf19 )\
                
\f3\b \cf20 for
\f2\b0 \cf19  i 
\f3\b \cf20 in
\f2\b0 \cf19  \cf24 0\cf19 ..<\cf29 numBuffers\cf19  \{\
                    \cf18 // Create a render pipeline state\cf19 \
                    
\f3\b \cf20 let
\f2\b0 \cf19  pipelineDescriptor = \cf31 MTLRenderPipelineDescriptor\cf19 ()\
                    pipelineDescriptor.\cf25 vertexFunction\cf19  = vertexFunction\
                    pipelineDescriptor.\cf25 fragmentFunction\cf19  = fragmentFunctions[i]\
                    pipelineDescriptor.\cf25 colorAttachments\cf19 [\cf24 0\cf19 ].\cf25 pixelFormat\cf19  = .\cf25 rgba16Unorm\cf19 \
\
                    \cf29 pipelineStates\cf19 .\cf26 append\cf19 ( 
\f3\b \cf20 try
\f2\b0 \cf19  \cf29 metalDevice\cf19 .\cf26 makeRenderPipelineState\cf19 (\cf26 descriptor\cf19 : pipelineDescriptor) )\
                \}\
                
\f3\b \cf20 let
\f2\b0 \cf19  pipelineDescriptor = \cf31 MTLRenderPipelineDescriptor\cf19 ()\
                pipelineDescriptor.\cf25 vertexFunction\cf19  = vertexFunction\
                pipelineDescriptor.\cf25 fragmentFunction\cf19  = fragmentFunctions[\cf29 numBuffers\cf19 ]\
                pipelineDescriptor.\cf25 colorAttachments\cf19 [\cf24 0\cf19 ].\cf25 pixelFormat\cf19  = .\cf25 bgra8Unorm\cf19 \
\
                \cf29 pipelineStates\cf19 .\cf26 append\cf19 ( 
\f3\b \cf20 try
\f2\b0 \cf19  \cf29 metalDevice\cf19 .\cf26 makeRenderPipelineState\cf19 (\cf26 descriptor\cf19 : pipelineDescriptor) )\
\
                \cf26 print\cf19 (\cf32 "shaders loaded"\cf19 )\
                DispatchQueue.\cf25 main\cf19 .\cf26 async\cf19  \{\
                    
\f3\b \cf20 if
\f2\b0 \cf19  !
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 renderMgr\cf19 .\cf29 vsyncOn\cf19  \{\
                        
\f3\b \cf20 self
\f2\b0 \cf19 .\cf30 startRendering\cf19 () \cf18 // renable offline rendering if vsync is false\cf19 \
                    \}\
                \}\
            \} 
\f3\b \cf20 catch
\f2\b0 \cf19  \{\
                DispatchQueue.\cf25 main\cf19 .\cf26 async\cf19  \{\
                    
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 renderMgr\cf19 .\cf29 shaderError\cf19  = \cf32 "Failed to setup shaders: \cf19 \\(error)\cf32 "\cf19 \
                \}\
                
\f3\b \cf20 return
\f2\b0 \cf19 \
            \}\
\
        \}\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 createRenderBuffer\cf19 (\cf23 _\cf19  size: \cf22 CGSize\cf19 ) -> \cf31 MTLTexture\cf19  \{\
            
\f3\b \cf20 let
\f2\b0 \cf19  offscreenTextureDescriptor = \cf31 MTLTextureDescriptor\cf19 .\cf26 texture2DDescriptor\cf19 (\cf26 pixelFormat\cf19 : .\cf25 rgba16Unorm\cf19 ,\
                                                                                \cf26 width\cf19 : \cf22 Int\cf19 (size.\cf25 width\cf19 ),\
                                                                                \cf26 height\cf19 : \cf22 Int\cf19 (size.\cf25 height\cf19 ),\
                                                                                \cf26 mipmapped\cf19 : 
\f3\b \cf20 false
\f2\b0 \cf19 )\
            offscreenTextureDescriptor.\cf25 usage\cf19  = [.\cf25 renderTarget\cf19 , .\cf25 shaderRead\cf19 ]\
            
\f3\b \cf20 let
\f2\b0 \cf19  buffer = \cf29 metalDevice\cf19 .\cf26 makeTexture\cf19 (\cf26 descriptor\cf19 : offscreenTextureDescriptor)!\
            
\f3\b \cf20 return
\f2\b0 \cf19  buffer\
        \}\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 setupRenderBuffers\cf19 (\cf23 _\cf19  size: \cf22 CGSize\cf19 ) \{\
            \cf18 // dealloc old buffers\cf19 \
            \cf29 renderBuffers\cf19 .\cf26 removeAll\cf19 ()\
            \cf18 // allocate new bufferss\cf19 \
            
\f3\b \cf20 for
\f2\b0 \cf19  _ 
\f3\b \cf20 in
\f2\b0 \cf19  \cf24 0\cf19 ..<\cf29 MAX_RENDER_BUFFERS\cf19  \{\
                \cf29 renderBuffers\cf19 .\cf26 append\cf19 (\cf30 createRenderBuffer\cf19 (size))\
            \}\
        \}\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 createUniformBuffers\cf19 () \{\
            \cf18 // 32 bytes is more than enough to hold SysUniforms, packed\cf19 \
            \cf29 sysUniformBuffer\cf19  = \cf29 metalDevice\cf19 .\cf26 makeBuffer\cf19 (\cf26 length\cf19 : \cf24 32\cf19 , \cf26 options\cf19 : .\cf25 storageModeShared\cf19 )\
        \}\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 updateViewportSize\cf19 (\cf23 _\cf19  size: \cf22 CGSize\cf19 ) \{\
            
\f3\b \cf20 var
\f2\b0 \cf19  viewportSize = \cf27 ViewportSize\cf19 (\cf30 width\cf19 : \cf22 Float\cf19 (size.\cf25 width\cf19 ), \cf30 height\cf19 : \cf22 Float\cf19 (size.\cf25 height\cf19 ))\
            
\f3\b \cf20 let
\f2\b0 \cf19  bufferPointer = \cf29 sysUniformBuffer\cf19 !.\cf26 contents\cf19 ()\
            \cf26 memcpy\cf19 (bufferPointer, &viewportSize, \cf22 MemoryLayout\cf19 <\cf27 ViewportSize\cf19 >.\cf25 size\cf19 )\
            \cf29 renderMgr\cf19 .\cf29 size\cf19 .\cf25 width\cf19  = size.\cf25 width\cf19 \
            \cf29 renderMgr\cf19 .\cf29 size\cf19 .\cf25 height\cf19  = size.\cf25 height\cf19 \
            \cf29 renderMgr\cf19 .\cf30 resetFrame\cf19 ()\
            \cf30 setupRenderBuffers\cf19 (size)\
            \cf29 renderMgr\cf19 .\cf29 uniformManager\cf19 .\cf30 setUniformTuple\cf19 (\cf32 "u_resolution"\cf19 , \cf30 values\cf19 : [\cf22 Float\cf19 (\cf29 renderMgr\cf19 .\cf29 size\cf19 .\cf25 width\cf19 ), \cf22 Float\cf19 (\cf29 renderMgr\cf19 .\cf29 size\cf19 .\cf25 height\cf19 )])\
        \}\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 reloadShaders\cf19 () \{\
            \cf29 frameCounter\cf19  = \cf24 0\cf19 \
            \cf29 renderMgr\cf19 .\cf29 reloadShaders\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 \
            \cf29 renderMgr\cf19 .\cf30 resetFrame\cf19 ()\
            \cf30 setupRenderBuffers\cf19 (\cf29 renderMgr\cf19 .\cf29 size\cf19 )\
            \cf30 setupShaders\cf19 (\cf29 renderMgr\cf19 .\cf29 selectedFile\cf19 )\
            \cf26 print\cf19 (\cf32 "shaders loading finished"\cf19 )\
        \}\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 mtkView\cf19 (\cf23 _\cf19  view: \cf31 MTKView\cf19 , \cf23 drawableSizeWillChange\cf19  size: \cf22 CGSize\cf19 ) \{\
            \cf29 renderSemaphore\cf19 .\cf26 wait\cf19 ()  \cf18 // wait until the resource is free to use\cf19 \
            
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 renderSemaphore\cf19 .\cf26 signal\cf19 () \}  \cf18 // signal that the resource is free now\cf19 \
            \cf30 updateViewportSize\cf19 (size)\
            \cf29 frameCounter\cf19  = \cf24 0\cf19 \
        \}\
\
        \cf18 // Enable offscreen rendering\cf19 \
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 startRendering\cf19 () \{\
            \cf29 renderingActive\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
            \cf30 renderOffscreen\cf19 ()\
        \}\
\
        \cf18 // Disable offscreen rendering\cf19 \
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 stopRendering\cf19 () \{\
            \cf29 renderingActive\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 \
        \}\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 updateVSyncState\cf19 (\cf23 _\cf19  enabled: \cf22 Bool\cf19 ) \{\
            \cf18 // Update your rendering logic here based on the VSync state\cf19 \
            
\f3\b \cf20 if
\f2\b0 \cf19  enabled \{\
                \cf30 stopRendering\cf19 ()\
            \} 
\f3\b \cf20 else
\f2\b0 \cf19  \{\
                \cf30 startRendering\cf19 ()\
            \}\
        \}\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 updateUniforms\cf19 () 
\f3\b \cf20 throws
\f2\b0 \cf19  \{\
            
\f3\b \cf20 var
\f2\b0 \cf19  offset = \cf22 MemoryLayout\cf19 <\cf27 ViewportSize\cf19 >.\cf25 size\cf19  \cf18 // for viewport\cf19 \
            
\f3\b \cf20 let
\f2\b0 \cf19  bufferPointer = \cf29 sysUniformBuffer\cf19 !.\cf26 contents\cf19 ()\
\
            \cf18 // Ensure the offset is aligned\cf19 \
            
\f3\b \cf20 var
\f2\b0 \cf19  memAlign = \cf22 MemoryLayout\cf19 <\cf22 UInt32\cf19 >.\cf25 alignment\cf19 \
            
\f3\b \cf20 var
\f2\b0 \cf19  memSize = \cf22 MemoryLayout\cf19 <\cf22 UInt32\cf19 >.\cf25 size\cf19 \
            offset = (offset + memAlign - \cf24 1\cf19 ) / memAlign * memAlign\
            \cf18 // Copy the data\cf19 \
            \cf26 memcpy\cf19 (bufferPointer.\cf26 advanced\cf19 (\cf26 by\cf19 : offset), &\cf29 frameCounter\cf19 , memSize)\
            \cf18 // Update the offset\cf19 \
            offset += memSize\
\
            
\f3\b \cf20 var
\f2\b0 \cf19  elapsedTime = \cf22 Float\cf19 (-\cf29 renderMgr\cf19 .\cf29 startDate\cf19 .\cf25 timeIntervalSinceNow\cf19 )\
            \cf18 // Ensure the offset is aligned\cf19 \
            memAlign = \cf22 MemoryLayout\cf19 <\cf22 Float\cf19 >.\cf25 alignment\cf19 \
            memSize = \cf22 MemoryLayout\cf19 <\cf22 Float\cf19 >.\cf25 size\cf19 \
            offset = (offset + memAlign - \cf24 1\cf19 ) / memAlign * memAlign\
            \cf18 // Copy the data\cf19 \
            \cf26 memcpy\cf19 (bufferPointer.\cf26 advanced\cf19 (\cf26 by\cf19 : offset), &elapsedTime, memSize)\
            \cf18 // Update the offset\cf19 \
            offset += memSize\
\
\
            
\f3\b \cf20 var
\f2\b0 \cf19  pNum = \cf29 numBuffers\cf19 \
            \cf18 // Ensure the offset is aligned\cf19 \
            memAlign = \cf22 MemoryLayout\cf19 <\cf22 UInt32\cf19 >.\cf25 alignment\cf19 \
            memSize = \cf22 MemoryLayout\cf19 <\cf22 UInt32\cf19 >.\cf25 size\cf19 \
            offset = (offset + memAlign - \cf24 1\cf19 ) / memAlign * memAlign\
            \cf18 // Copy the data\cf19 \
            \cf26 memcpy\cf19 (bufferPointer.\cf26 advanced\cf19 (\cf26 by\cf19 : offset), &pNum, memSize)\
            \cf18 // Update the offset\cf19 \
            offset += memSize\
\
            
\f3\b \cf20 try
\f2\b0 \cf19  \cf29 renderMgr\cf19 .\cf29 uniformManager\cf19 .\cf30 mapUniformsToBuffer\cf19 ()\
        \}\
\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 setupRenderEncoder\cf19 ( \cf23 _\cf19  encoder: \cf31 MTLRenderCommandEncoder\cf19  ) \{\
            
\f3\b \cf20 for
\f2\b0 \cf19  i 
\f3\b \cf20 in
\f2\b0 \cf19  \cf24 0\cf19 ..<\cf29 MAX_RENDER_BUFFERS\cf19  \{\
                encoder.\cf26 setFragmentTexture\cf19 (\cf29 renderBuffers\cf19 [i], \cf26 index\cf19 : i)\
            \}\
            \cf18 // pass a dynamic reference to the last buffer rendered, if there is one\cf19 \
            
\f3\b \cf20 if
\f2\b0 \cf19  \cf29 numBuffers\cf19  > \cf24 0\cf19  \{\
                encoder.\cf26 setFragmentTexture\cf19 (\cf29 renderBuffers\cf19 [\cf29 numBuffers\cf19 -\cf24 1\cf19 ], \cf26 index\cf19 : \cf29 MAX_RENDER_BUFFERS\cf19 )\
            \}\
\
            \cf18 // now the first MAX_RENDER_BUFFERS+1 buffers are passed\cf19 \
            \cf18 // it's up to the shaders how to use them\cf19 \
\
            
\f3\b \cf20 do
\f2\b0 \cf19  \{\
                
\f3\b \cf20 try
\f2\b0 \cf19  \cf30 updateUniforms\cf19 ()\
                encoder.\cf26 setFragmentBuffer\cf19 (\cf29 sysUniformBuffer\cf19 , \cf26 offset\cf19 : \cf24 0\cf19 , \cf26 index\cf19 : \cf24 0\cf19 )\
                encoder.\cf26 setFragmentBuffer\cf19 (\cf29 renderMgr\cf19 .\cf29 uniformManager\cf19 .\cf29 buffer\cf19 , \cf26 offset\cf19 : \cf24 0\cf19 , \cf26 index\cf19 : \cf24 1\cf19 )\
                encoder.\cf26 drawPrimitives\cf19 (\cf26 type\cf19 : .\cf25 triangle\cf19 , \cf26 vertexStart\cf19 : \cf24 0\cf19 , \cf26 vertexCount\cf19 : \cf24 3\cf19 )\
            \} 
\f3\b \cf20 catch
\f2\b0 \cf19  \{\
                \cf26 print\cf19 (\cf32 "Failed to setup render encoder: \cf19 \\(error)\cf32 "\cf19 )\
            \}\
        \}\
\
        
\f3\b \cf20 @objc
\f2\b0 \cf19  
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 renderOffscreen\cf19 () \{\
            \cf29 renderQueue\cf19 .\cf26 async\cf19  \{ [
\f3\b \cf20 weak
\f2\b0 \cf19  
\f3\b \cf20 self
\f2\b0 \cf19 ] 
\f3\b \cf20 in
\f2\b0 \cf19 \
                
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  self = 
\f3\b \cf20 self
\f2\b0 \cf19  
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
                
\f3\b \cf20 guard
\f2\b0 \cf19  self.\cf29 numBuffers\cf19  > \cf24 0\cf19  
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
                
\f3\b \cf20 if
\f2\b0 \cf19 ( !\cf29 renderingActive\cf19  && !\cf29 renderMgr\cf19 .\cf29 vsyncOn\cf19  ) \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
\
                self.\cf29 renderSemaphore\cf19 .\cf26 wait\cf19 ()  \cf18 // Ensure exclusive access to render buffers\cf19 \
                
\f3\b \cf20 defer
\f2\b0 \cf19  \{ self.\cf29 renderSemaphore\cf19 .\cf26 signal\cf19 () \}  \cf18 // Release the lock after updating\cf19 \
\
                
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  commandBuffer = \cf29 metalCommandQueue\cf19 .\cf26 makeCommandBuffer\cf19 () 
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
\
                
\f3\b \cf20 var
\f2\b0 \cf19  i=\cf24 0\cf19 \
\
                \cf18 // iterate through the shaders, giving them each access to all of the buffers\cf19 \
                \cf18 // (see the pipeline setup)\cf19 \
                
\f3\b \cf20 while
\f2\b0 \cf19  i < (\cf29 numBuffers\cf19 ) \{\
                    
\f3\b \cf20 let
\f2\b0 \cf19  renderPassDescriptor = \cf31 MTLRenderPassDescriptor\cf19 ()\
                    renderPassDescriptor.\cf25 colorAttachments\cf19 [\cf24 0\cf19 ].\cf25 texture\cf19  = \cf29 renderBuffers\cf19 [i]\
                    renderPassDescriptor.\cf25 colorAttachments\cf19 [\cf24 0\cf19 ].\cf25 loadAction\cf19  = .\cf25 load\cf19 \
                    renderPassDescriptor.\cf25 colorAttachments\cf19 [\cf24 0\cf19 ].\cf25 storeAction\cf19  = .\cf25 store\cf19 \
\
                    
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  commandEncoder = commandBuffer.\cf26 makeRenderCommandEncoder\cf19 (\cf26 descriptor\cf19 : renderPassDescriptor) 
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
\
                    commandEncoder.\cf26 setRenderPipelineState\cf19 (\cf29 pipelineStates\cf19 [i])\
                    \cf30 setupRenderEncoder\cf19 (commandEncoder)\
                    commandEncoder.\cf26 endEncoding\cf19 ()\
\
                    i += \cf24 1\cf19 \
                \}\
\
                \cf18 // This is the most optimal way I found to do offline rendering\cf19 \
                \cf18 // as quickly as possible.  The drawback is that slower renderings\cf19 \
                \cf18 // like circle_and_lines don't display smoothly even though\cf19 \
                \cf18 // framerates are faster than 60Hz.\cf19 \
                
\f3\b \cf20 if
\f2\b0 \cf19 ( !\cf29 renderMgr\cf19 .\cf29 vsyncOn\cf19  ) \{\
                    commandBuffer.\cf26 addScheduledHandler\cf19  \{ commandBuffer 
\f3\b \cf20 in
\f2\b0 \cf19 \
                        self.\cf30 renderOffscreen\cf19 ()\
                    \}\
                \}\
                self.\cf29 frameCounter\cf19  += \cf24 1\cf19 \
                commandBuffer.\cf26 commit\cf19 ()\
            \}\
        \}\
\
        
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 draw\cf19 (\cf23 in\cf19  view: \cf31 MTKView\cf19 ) \{\
            \cf29 renderSemaphore\cf19 .\cf26 wait\cf19 ()  \cf18 // wait until the resource is free to use\cf19 \
            
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 renderSemaphore\cf19 .\cf26 signal\cf19 () \}  \cf18 // signal that the resource is free now\cf19 \
\
            
\f3\b \cf20 if
\f2\b0 \cf19 ( \cf29 renderMgr\cf19 .\cf29 reloadShaders\cf19  ) \{\
                \cf30 reloadShaders\cf19 ()\
            \}\
\
            
\f3\b \cf20 guard
\f2\b0 \cf19  !\cf29 renderMgr\cf19 .\cf29 renderingPaused\cf19  
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
            
\f3\b \cf20 guard
\f2\b0 \cf19  \cf29 pipelineStates\cf19 .\cf25 count\cf19  - \cf24 1\cf19  == \cf29 numBuffers\cf19  
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
            
\f3\b \cf20 if
\f2\b0 \cf19 ( \cf29 renderMgr\cf19 .\cf29 vsyncOn\cf19  && \cf29 numBuffers\cf19  > \cf24 0\cf19  ) \{ \cf30 renderOffscreen\cf19 () \} 
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 frameCounter\cf19  += \cf24 1\cf19  \}\
            
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  drawable = view.\cf25 currentDrawable\cf19 ,\
                  
\f3\b \cf20 let
\f2\b0 \cf19  commandBuffer = \cf29 metalCommandQueue\cf19 .\cf26 makeCommandBuffer\cf19 () 
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
\
            
\f3\b \cf20 let
\f2\b0 \cf19  renderPassDescriptor = view.\cf25 currentRenderPassDescriptor\cf19 !\
\
            \cf18 // renderPassDescriptor.colorAttachments[0].texture = renderBuffers[numBuffers-1]\cf19 \
            renderPassDescriptor.\cf25 colorAttachments\cf19 [\cf24 0\cf19 ].\cf25 loadAction\cf19  = .\cf25 load\cf19 \
            renderPassDescriptor.\cf25 colorAttachments\cf19 [\cf24 0\cf19 ].\cf25 storeAction\cf19  = .\cf25 store\cf19 \
\
            
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  commandEncoder = commandBuffer.\cf26 makeRenderCommandEncoder\cf19 (\cf26 descriptor\cf19 : renderPassDescriptor) 
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
\
            commandEncoder.\cf26 setRenderPipelineState\cf19 (\cf29 pipelineStates\cf19 [\cf29 numBuffers\cf19 ])\
            \cf30 setupRenderEncoder\cf19 (commandEncoder)\
            commandEncoder.\cf26 endEncoding\cf19 ()\
\
            commandBuffer.\cf26 present\cf19 (drawable)\
            commandBuffer.\cf26 commit\cf19 ()\
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 renderMgr\cf19 .\cf29 frameCount\cf19  = 
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 frameCounter\cf19  \cf18 // right now, this will trigger a view update since the RenderModel's\cf19 \
            \cf18 // model.frameCount is observed by ContentView forcing redraw\cf19 \
        \}\
\
    \}\
\}\
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
-\
\
\pard\tx593\pardeftab593\partightenfactor0

\f2\fs24 \cf18 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 //\cf19 \
\cf18 //  UniformManager.swift\cf19 \
\cf18 //  MetalGemini\cf19 \
\cf18 //\cf19 \
\cf18 //  Created by Bill Doughty on 4/17/24.\cf19 \
\cf18 //\cf19 \
\

\f3\b \cf20 import
\f2\b0 \cf19  Foundation\

\f3\b \cf20 import
\f2\b0 \cf19  MetalKit\

\f3\b \cf20 import
\f2\b0 \cf19  AppKit\

\f3\b \cf20 import
\f2\b0 \cf19  SwiftOSC\
\
\cf18 // Extension for Array of Floats to easily convert array to SIMD4<Float>\cf19 \

\f3\b \cf20 extension
\f2\b0 \cf19  \cf21 Array\cf19  
\f3\b \cf20 where
\f2\b0 \cf19  Element == \cf22 Float\cf19 \
\{\
    \cf18 // Convert the array to SIMD4<Float>, padding with zeros if necessary\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 toSIMD4\cf19 () -> \cf22 SIMD4\cf19 <\cf22 Float\cf19 >? \{\
        
\f3\b \cf20 var
\f2\b0 \cf19  c = 
\f3\b \cf20 self
\f2\b0 \cf19 \
        
\f3\b \cf20 while
\f2\b0 \cf19 ( c.\cf25 count\cf19  < \cf24 4\cf19  ) \{ c.\cf26 append\cf19 (\cf24 0\cf19 ) \} \cf18 // Pad with zeros if less than 4 elements\cf19 \
        
\f3\b \cf20 return
\f2\b0 \cf19  \cf22 SIMD4\cf19 <\cf22 Float\cf19 >(c[\cf24 0\cf19 ], c[\cf24 1\cf19 ], c[\cf24 2\cf19 ], c[\cf24 3\cf19 ])\
    \}\
\}\
\
\cf18 // A thread-safe dictionary to manage SIMD4<Float> values with string keys\cf19 \

\f3\b \cf20 class
\f2\b0 \cf19  \cf21 Float4Dictionary\cf19 \
\{\
    
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 semaphore\cf19  = DispatchSemaphore(value: \cf24 1\cf19 ) \cf18 // Ensures thread-safe access to the dictionary\cf19 \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 map\cf19 : [\cf22 String\cf19 : \cf22 SIMD4\cf19 <\cf22 Float\cf19 >] = [:]\
\
    
\f3\b \cf20 init
\f2\b0 \cf19 () \{\}\
\
    \cf18 // Set a SIMD4<Float> value from an array of floats for the specified key\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 setTuple\cf19 ( \cf23 _\cf19  key: \cf22 String\cf19 , \cf23 values\cf19 : [\cf22 Float\cf19 ])\
    \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()  \cf18 // Lock access to ensure thread safety\cf19 \
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}  \cf18 // Unlock after operation\cf19 \
        
\f3\b \cf20 let
\f2\b0 \cf19  value = values.\cf30 toSIMD4\cf19 ()\
        \cf29 map\cf19 [key] = value\
    \}\
\
    \cf18 // Set a SIMD4<Float> value directly for the specified key\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 set\cf19 ( \cf23 _\cf19  key: \cf22 String\cf19 , \cf23 _\cf19  simd4: \cf22 SIMD4\cf19 <\cf22 Float\cf19 > )\
    \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        \cf29 map\cf19 [key] = simd4\
    \}\
\
    \cf18 // Retrieve a SIMD4<Float> value for the specified key, or return a default value\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 get\cf19 ( \cf23 _\cf19  key: \cf22 String\cf19 , \cf23 _\cf19  defaultValue: \cf22 SIMD4\cf19 <\cf22 Float\cf19 > = \cf22 SIMD4\cf19 <\cf22 Float\cf19 >(\cf24 0\cf19 ,\cf24 0\cf19 ,\cf24 0\cf19 ,\cf24 0\cf19 ) ) -> \cf22 SIMD4\cf19 <\cf22 Float\cf19 >\
    \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        
\f3\b \cf20 return
\f2\b0 \cf19  \cf29 map\cf19 [key, 
\f3\b \cf20 default
\f2\b0 \cf19 : defaultValue]\
    \}\
\
    \cf18 // Retrieve the first component (Float) from a SIMD4<Float> for the specified key\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 getAsFloat\cf19 ( \cf23 _\cf19  key: \cf22 String\cf19 , \cf23 _\cf19  defaultValue: \cf22 Float\cf19  = \cf24 0\cf19  ) -> \cf22 Float\cf19 \
    \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  float4 = \cf29 map\cf19 [key] 
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  defaultValue \}\
        
\f3\b \cf20 return
\f2\b0 \cf19  float4.\cf25 x\cf19 \
    \}\
\
    \cf18 // Retrieve the first two components (SIMD2<Float>) from a SIMD4<Float> for the specified key\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 getAsFloat2\cf19 ( \cf23 _\cf19  key: \cf22 String\cf19 , \cf23 _\cf19  defaultValue: \cf22 SIMD2\cf19 <\cf22 Float\cf19 > = \cf22 SIMD2\cf19 <\cf22 Float\cf19 >(\cf24 0\cf19 ,\cf24 0\cf19 )) -> \cf22 SIMD2\cf19 <\cf22 Float\cf19 >\
    \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  float4 = \cf29 map\cf19 [key] 
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  defaultValue \}\
        
\f3\b \cf20 return
\f2\b0 \cf19  \cf22 SIMD2\cf19 <\cf22 Float\cf19 >(float4.\cf25 x\cf19 ,float4.\cf25 y\cf19 )\
    \}\
\
    \cf18 // Retrieve the first three components (SIMD3<Float>) from a SIMD4<Float> for the specified key\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 getAsFloat3\cf19 ( \cf23 _\cf19  key: \cf22 String\cf19 , \cf23 _\cf19  defaultValue: \cf22 SIMD3\cf19 <\cf22 Float\cf19 > = \cf22 SIMD3\cf19 <\cf22 Float\cf19 >(\cf24 0\cf19 ,\cf24 0\cf19 ,\cf24 0\cf19 )) -> \cf22 SIMD3\cf19 <\cf22 Float\cf19 >\
    \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  float4 = \cf29 map\cf19 [key] 
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  defaultValue \}\
        
\f3\b \cf20 return
\f2\b0 \cf19  \cf22 SIMD3\cf19 <\cf22 Float\cf19 >(float4.\cf25 x\cf19 ,float4.\cf25 y\cf19 ,float4.\cf25 z\cf19 )\
    \}\
\
    \cf18 // Remove and return the SIMD4<Float> value for the specified key\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 delete\cf19 ( \cf23 _\cf19  key: \cf22 String\cf19  ) -> \cf22 SIMD4\cf19 <\cf22 Float\cf19 >?\
    \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        
\f3\b \cf20 return
\f2\b0 \cf19  \cf29 map\cf19 .\cf26 removeValue\cf19 (\cf26 forKey\cf19 : key)\
    \}\
\
    \cf18 // Clear all entries in the dictionary\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 clear\cf19 () \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        \cf29 map\cf19 .\cf26 removeAll\cf19 ()\
    \}\
\}\
\
\cf18 // Manages uniforms for Metal applications, ensuring they are thread-safe and properly managed\cf19 \

\f3\b \cf20 class
\f2\b0 \cf19  \cf21 UniformManager\cf19 \
\{\
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 parameterMap\cf19 : [\cf22 String\cf19 : \cf22 Int\cf19 ] = [:] \cf18 // Map from uniform names to their indices\cf19 \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 indexMap\cf19 : [(\cf22 String\cf19 ,\cf22 String\cf19 )] = [] \cf18 // Tuple storing uniform names and their types\cf19 \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 float4dict\cf19  = \cf28 Float4Dictionary\cf19 () \cf18 // Dictionary to store uniform values\cf19 \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 dirty\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19  \cf18 // Flag to indicate if the buffer needs updating\cf19 \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 buffer\cf19 : \cf31 MTLBuffer\cf19 ? \cf18 // Metal buffer for storing uniform data\cf19 \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 debug\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19  \cf18 // Debug flag to enable logging\cf19 \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 uniformsTxtURL\cf19 : \cf22 URL\cf19 ? \cf18 // URL for the uniforms file\cf19 \
    
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 uniformProjectDirURL\cf19 : \cf22 URL\cf19 ? \cf18 // Directory URL for the project\cf19 \
    
\f3\b \cf20 let
\f2\b0 \cf19  \cf23 bookmarkID\cf19  = \cf32 "net.wdoughty.metaltoy.projectdir"\cf19  \cf18 // Bookmark ID for sandboxed file access\cf19 \
    
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 oscServer\cf19 : \cf28 OSCServerManager\cf19 !\
    
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 semaphore\cf19  = DispatchSemaphore(value: \cf24 1\cf19 ) \cf18 // Ensures thread-safe access to the dirty flag\cf19 \
\
    
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 saveWorkItem\cf19 : \cf31 DispatchWorkItem\cf19 ? \cf18 // Work item for saving uniforms\cf19 \
    
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 var
\f2\b0 \cf19  \cf23 saveQueue\cf19  = DispatchQueue(\cf26 label\cf19 : \cf32 "net.wdoughty.metaltoy.saveUniformsQueue"\cf19 ) \cf18 // Queue for saving operations\cf19 \
\
    
\f3\b \cf20 init
\f2\b0 \cf19 () \{\
        \cf29 oscServer\cf19  = \cf28 OSCServerManager\cf19 (\cf30 uniformManager\cf19 : 
\f3\b \cf20 self
\f2\b0 \cf19 )\
        \cf30 setupOSCServer\cf19 ()\
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 setupOSCServer\cf19 () \{\
        \cf29 oscServer\cf19 .\cf30 startServer\cf19 ()\
    \}\
\
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 recvOscMsg\cf19 (\cf23 _\cf19  message: \cf28 OSCMessage\cf19 ) \{\
        \cf18 // Handle incoming OSC message here\cf19 \
\
        
\f3\b \cf20 let
\f2\b0 \cf19  oscRegex = \cf32 /\cf19 [\\\cf32 /\cf19 \\d]*?(\\w+).*\cf32 /\cf19 \
        
\f3\b \cf20 if
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  firstMatch = message.\cf29 address\cf19 .\cf29 string\cf19 .\cf26 firstMatch\cf19 (\cf26 of\cf19 : oscRegex) \{\
            
\f3\b \cf20 let
\f2\b0 \cf19  name = firstMatch.\cf24 1\cf19 \
            
\f3\b \cf20 var
\f2\b0 \cf19  tuple:[\cf22 Float\cf19 ] = []\
            
\f3\b \cf20 for
\f2\b0 \cf19  argument 
\f3\b \cf20 in
\f2\b0 \cf19  message.\cf29 arguments\cf19  \{\
                
\f3\b \cf20 if
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  float = argument 
\f3\b \cf20 as
\f2\b0 \cf19 ? \cf22 Float\cf19  \{\
                    tuple.\cf26 append\cf19 (float)\
                \} 
\f3\b \cf20 else
\f2\b0 \cf19  
\f3\b \cf20 if
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  double = argument 
\f3\b \cf20 as
\f2\b0 \cf19 ? \cf22 Double\cf19  \{\
                    \cf26 print\cf19 (\cf32 "WARNING: \cf19 \\(name)\cf32  sent \cf19 \\(double)\cf32  as double"\cf19 )\
                \}\
\
            \}\
            
\f3\b \cf20 self
\f2\b0 \cf19 .\cf30 setUniformTuple\cf19 (\cf22 String\cf19 (name), \cf30 values\cf19 : tuple)\
\
        \}\
\cf18 //            print("Received OSC message: \\(message.address.string), \\(String(describing: message.arguments))")\cf19 \
    \}\
\
    \cf18 // Open a panel to select a directory for storing project files\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 selectDirectory\cf19 () \{\
        DispatchQueue.\cf25 main\cf19 .\cf26 async\cf19  \{\
\
            
\f3\b \cf20 let
\f2\b0 \cf19  openPanel = \cf31 NSOpenPanel\cf19 ()\
            openPanel.\cf25 title\cf19  = \cf32 "Choose a directory"\cf19 \
            openPanel.\cf25 message\cf19  = \cf32 "Select the directory containing your shader file"\cf19 \
            openPanel.\cf25 showsResizeIndicator\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
            openPanel.\cf25 showsHiddenFiles\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 \
            openPanel.\cf25 canChooseDirectories\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
            openPanel.\cf25 canCreateDirectories\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
            openPanel.\cf25 canChooseFiles\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 \
            openPanel.\cf25 allowsMultipleSelection\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 \
\
            openPanel.\cf26 begin\cf19  \{ (result) 
\f3\b \cf20 in
\f2\b0 \cf19 \
                
\f3\b \cf20 if
\f2\b0 \cf19  result == .OK \{\
                    
\f3\b \cf20 if
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  selectedPath = openPanel.\cf25 url\cf19  \{\
                        \cf26 print\cf19 (\cf32 "Directory selected: \cf19 \\(selectedPath.\cf25 path\cf19 )\cf32 "\cf19 )\
                        
\f3\b \cf20 self
\f2\b0 \cf19 .\cf30 storeSecurityScopedBookmark\cf19 (\cf30 for\cf19 : selectedPath, \cf30 withIdentifier\cf19 : 
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 bookmarkID\cf19 )\
                        
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 uniformProjectDirURL\cf19  = selectedPath\
                    \}\
                \} 
\f3\b \cf20 else
\f2\b0 \cf19  \{\
                    \cf26 print\cf19 (\cf32 "User cancelled the open panel"\cf19 )\
                \}\
            \}\
        \}\
    \}\
\
    \cf18 // Store a security-scoped bookmark to persist access to the directory across app launches\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 storeSecurityScopedBookmark\cf19 (\cf23 for\cf19  directory: \cf22 URL\cf19 , \cf23 withIdentifier\cf19  identifier: \cf22 String\cf19 ) \{\
        
\f3\b \cf20 do
\f2\b0 \cf19  \{\
            
\f3\b \cf20 let
\f2\b0 \cf19  bookmarkData = 
\f3\b \cf20 try
\f2\b0 \cf19  directory.\cf26 bookmarkData\cf19 (\cf26 options\cf19 : .\cf25 withSecurityScope\cf19 , \cf26 includingResourceValuesForKeys\cf19 : 
\f3\b \cf20 nil
\f2\b0 \cf19 , \cf26 relativeTo\cf19 : 
\f3\b \cf20 nil
\f2\b0 \cf19 )\
            \cf31 UserDefaults\cf19 .\cf25 standard\cf19 .\cf26 set\cf19 (bookmarkData, \cf26 forKey\cf19 : \cf32 "bookmark_\cf19 \\(identifier)\cf32 "\cf19 )\
            \cf26 print\cf19 (\cf32 "Bookmark for \cf19 \\(identifier)\cf32  saved successfully."\cf19 )\
        \} 
\f3\b \cf20 catch
\f2\b0 \cf19  \{\
            \cf26 print\cf19 (\cf32 "Failed to create bookmark for \cf19 \\(identifier)\cf32 : \cf19 \\(error)\cf32 "\cf19 )\
        \}\
    \}\
\
    \cf18 // Access a directory using a stored bookmark, performing a file operation within the bookmark's scope\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 accessBookmarkedDirectory\cf19 (\cf23 withIdentifier\cf19  identifier: \cf22 String\cf19 , \cf23 using\cf19  fileOperation: (\cf22 URL\cf19 ) -> \cf22 Void\cf19 ) \{\
        
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  bookmarkData = \cf31 UserDefaults\cf19 .\cf25 standard\cf19 .\cf26 data\cf19 (\cf26 forKey\cf19 : \cf32 "bookmark_\cf19 \\(identifier)\cf32 "\cf19 ) 
\f3\b \cf20 else
\f2\b0 \cf19  \{\
            \cf26 print\cf19 (\cf32 "No bookmark data found for \cf19 \\(identifier)\cf32 ."\cf19 )\
            
\f3\b \cf20 return
\f2\b0 \cf19 \
        \}\
\
        
\f3\b \cf20 var
\f2\b0 \cf19  isStale = 
\f3\b \cf20 false
\f2\b0 \cf19 \
        
\f3\b \cf20 do
\f2\b0 \cf19  \{\
            
\f3\b \cf20 let
\f2\b0 \cf19  bookmarkedURL = 
\f3\b \cf20 try
\f2\b0 \cf19  \cf22 URL\cf19 (\cf26 resolvingBookmarkData\cf19 : bookmarkData, \cf26 options\cf19 : .\cf25 withSecurityScope\cf19 , \cf26 relativeTo\cf19 : 
\f3\b \cf20 nil
\f2\b0 \cf19 , \cf26 bookmarkDataIsStale\cf19 : &isStale)\
            
\f3\b \cf20 if
\f2\b0 \cf19  isStale \{\
                \cf26 print\cf19 (\cf32 "Bookmark for \cf19 \\(identifier)\cf32  is stale, need to refresh"\cf19 )\
                \cf30 selectDirectory\cf19 ()\
            \} 
\f3\b \cf20 else
\f2\b0 \cf19  \{\
                
\f3\b \cf20 if
\f2\b0 \cf19  bookmarkedURL.\cf26 startAccessingSecurityScopedResource\cf19 () \{\
                    fileOperation(bookmarkedURL)\
                    bookmarkedURL.\cf26 stopAccessingSecurityScopedResource\cf19 ()\
                \}\
            \}\
        \} 
\f3\b \cf20 catch
\f2\b0 \cf19  \{\
            \cf26 print\cf19 (\cf32 "Error resolving bookmark for \cf19 \\(identifier)\cf32 : \cf19 \\(error)\cf32 "\cf19 )\
        \}\
    \}\
\
    \cf18 // Schedule a task to save the uniforms to a file, cancelling any previous scheduled task\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 requestSaveUniforms\cf19 () \{\
        \cf29 saveWorkItem\cf19 ?.\cf26 cancel\cf19 () \cf18 // Cancel the previous task if it exists\cf19 \
        \cf29 saveWorkItem\cf19  = \cf31 DispatchWorkItem\cf19  \{ [
\f3\b \cf20 weak
\f2\b0 \cf19  
\f3\b \cf20 self
\f2\b0 \cf19 ] 
\f3\b \cf20 in
\f2\b0 \cf19 \
            
\f3\b \cf20 self
\f2\b0 \cf19 ?.\cf30 saveUniformsToFile\cf19 ()\
        \}\
\
        \cf18 // Schedule the save after a delay (e.g., 500 milliseconds)\cf19 \
        
\f3\b \cf20 if
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  saveWorkItem = \cf29 saveWorkItem\cf19  \{\
            \cf29 saveQueue\cf19 .\cf26 asyncAfter\cf19 (\cf26 deadline\cf19 : .\cf26 now\cf19 () + \cf24 0.5\cf19 , \cf26 execute\cf19 : saveWorkItem)\
        \}\
    \}\
\
    \cf18 // Reset mapping of uniform names to buffer indices and types, marking the system as needing an update\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 resetMapping\cf19 () \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        \cf29 parameterMap\cf19 .\cf26 removeAll\cf19 ()\
        \cf29 indexMap\cf19 .\cf26 removeAll\cf19 ()\
        \cf29 dirty\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
    \}\
\
    \cf18 // Clear all uniforms from the dictionary and mark as dirty\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 clearUniforms\cf19 () \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        \cf29 float4dict\cf19 .\cf30 clear\cf19 ()\
        \cf29 dirty\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
    \}\
\
    \cf18 // Add a new uniform with the given name and type, returning its new index\cf19 \
    
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 setIndex\cf19 (\cf23 name\cf19 : \cf22 String\cf19 , \cf23 type\cf19 : \cf22 String\cf19  ) -> \cf22 Int\cf19 \
    \{\
        \cf29 indexMap\cf19 .\cf26 append\cf19 ((name,type))\
        
\f3\b \cf20 let
\f2\b0 \cf19  index = \cf29 indexMap\cf19 .\cf25 count\cf19 -\cf24 1\cf19 \
        \cf29 parameterMap\cf19 [name] = index\
        \cf29 dirty\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
        
\f3\b \cf20 return
\f2\b0 \cf19  index\
    \}\
\
    \cf18 // Set a uniform value from an array of floats, optionally suppressing the file save operation\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 setUniformTuple\cf19 ( \cf23 _\cf19  name: \cf22 String\cf19 , \cf23 values\cf19 : [\cf22 Float\cf19 ], \cf23 suppressSave\cf19 :\cf22 Bool\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 )\
    \{\
        
\f3\b \cf20 if
\f2\b0 \cf19  !suppressSave \{\
            \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        \}\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        \cf29 float4dict\cf19 .\cf30 setTuple\cf19 (name, \cf30 values\cf19 : values)\
        \cf29 dirty\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
        
\f3\b \cf20 if
\f2\b0 \cf19 ( !suppressSave ) \{\
            \cf30 requestSaveUniforms\cf19 ()\
            
\f3\b \cf20 if
\f2\b0 \cf19 ( \cf29 debug\cf19  ) \{ \cf30 printUniforms\cf19 () \}\
        \}\
    \}\
\
    \cf18 // Set a SIMD4<Float> uniform value and schedule a file save\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 setUniform\cf19 ( \cf23 _\cf19  name: \cf22 String\cf19 , \cf23 _\cf19  simd4: \cf22 SIMD4\cf19 <\cf22 Float\cf19 > )\
    \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        \cf29 float4dict\cf19 .\cf30 set\cf19 (name, simd4)\
        \cf29 dirty\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
        \cf30 requestSaveUniforms\cf19 () \cf18 // This debounces and schedules a save operation\cf19 \
    \}\
\
    \cf18 // Update the uniforms buffer if necessary, handling data alignment and copying\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 mapUniformsToBuffer\cf19 () 
\f3\b \cf20 throws
\f2\b0 \cf19  \{\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        
\f3\b \cf20 if
\f2\b0 \cf19  !\cf29 dirty\cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
        \cf29 dirty\cf19  = 
\f3\b \cf20 false
\f2\b0 \cf19 \
        
\f3\b \cf20 if
\f2\b0 \cf19  \cf29 debug\cf19  \{ \cf26 print\cf19 (\cf32 "Updating uniforms buffer"\cf19 ) \}\
        
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  buffer = 
\f3\b \cf20 self
\f2\b0 \cf19 .\cf29 buffer\cf19  
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
\
        
\f3\b \cf20 var
\f2\b0 \cf19  offset = \cf24 0\cf19 \
        
\f3\b \cf20 for
\f2\b0 \cf19  i 
\f3\b \cf20 in
\f2\b0 \cf19  \cf24 0\cf19 ..<\cf29 indexMap\cf19 .\cf25 count\cf19  \{\
            
\f3\b \cf20 let
\f2\b0 \cf19  (key, dataType) = \cf29 indexMap\cf19 [i]\
            
\f3\b \cf20 switch
\f2\b0 \cf19  dataType \{\
            
\f3\b \cf20 case
\f2\b0 \cf19  \cf32 "float"\cf19 :\
                
\f3\b \cf20 var
\f2\b0 \cf19  data = \cf29 float4dict\cf19 .\cf30 getAsFloat\cf19 (key)\
                \cf18 // Ensure the offset is aligned\cf19 \
                offset = (offset + \cf22 MemoryLayout\cf19 <\cf22 Float\cf19 >.\cf25 alignment\cf19  - \cf24 1\cf19 ) / \cf22 MemoryLayout\cf19 <\cf22 Float\cf19 >.\cf25 alignment\cf19  * \cf22 MemoryLayout\cf19 <\cf22 Float\cf19 >.\cf25 alignment\cf19 \
                \cf18 // Copy the data\cf19 \
                \cf26 memcpy\cf19 (buffer.\cf26 contents\cf19 ().\cf26 advanced\cf19 (\cf26 by\cf19 : offset), &data, \cf22 MemoryLayout\cf19 <\cf22 Float\cf19 >.\cf25 size\cf19 )\
                \cf18 // Update the offset\cf19 \
                offset += \cf22 MemoryLayout\cf19 <\cf22 Float\cf19 >.\cf25 size\cf19 \
            
\f3\b \cf20 case
\f2\b0 \cf19  \cf32 "float2"\cf19 :\
                
\f3\b \cf20 var
\f2\b0 \cf19  data = \cf29 float4dict\cf19 .\cf30 getAsFloat2\cf19 (key)\
                offset = (offset + \cf22 MemoryLayout\cf19 <\cf22 SIMD2\cf19 <\cf22 Float\cf19 >>.\cf25 alignment\cf19  - \cf24 1\cf19 ) / \cf22 MemoryLayout\cf19 <\cf22 SIMD2\cf19 <\cf22 Float\cf19 >>.\cf25 alignment\cf19  * \cf22 MemoryLayout\cf19 <\cf22 SIMD2\cf19 <\cf22 Float\cf19 >>.\cf25 alignment\cf19 \
                \cf26 memcpy\cf19 (buffer.\cf26 contents\cf19 ().\cf26 advanced\cf19 (\cf26 by\cf19 : offset), &data, \cf22 MemoryLayout\cf19 <\cf22 SIMD3\cf19 <\cf22 Float\cf19 >>.\cf25 size\cf19 )\
                offset += \cf22 MemoryLayout\cf19 <\cf22 SIMD2\cf19 <\cf22 Float\cf19 >>.\cf25 size\cf19 \
            
\f3\b \cf20 case
\f2\b0 \cf19  \cf32 "float3"\cf19 :\
                
\f3\b \cf20 var
\f2\b0 \cf19  data = \cf29 float4dict\cf19 .\cf30 getAsFloat3\cf19 (key)\
                offset = (offset + \cf22 MemoryLayout\cf19 <\cf22 SIMD3\cf19 <\cf22 Float\cf19 >>.\cf25 alignment\cf19  - \cf24 1\cf19 ) / \cf22 MemoryLayout\cf19 <\cf22 SIMD3\cf19 <\cf22 Float\cf19 >>.\cf25 alignment\cf19  * \cf22 MemoryLayout\cf19 <\cf22 SIMD3\cf19 <\cf22 Float\cf19 >>.\cf25 alignment\cf19 \
                \cf26 memcpy\cf19 (buffer.\cf26 contents\cf19 ().\cf26 advanced\cf19 (\cf26 by\cf19 : offset), &data, \cf22 MemoryLayout\cf19 <\cf22 SIMD3\cf19 <\cf22 Float\cf19 >>.\cf25 size\cf19 )\
                offset += \cf22 MemoryLayout\cf19 <\cf22 SIMD3\cf19 <\cf22 Float\cf19 >>.\cf25 size\cf19 \
            
\f3\b \cf20 case
\f2\b0 \cf19  \cf32 "float4"\cf19 :\
                
\f3\b \cf20 var
\f2\b0 \cf19  data = \cf29 float4dict\cf19 .\cf30 get\cf19 (key)\
                offset = (offset + \cf22 MemoryLayout\cf19 <\cf22 SIMD4\cf19 <\cf22 Float\cf19 >>.\cf25 alignment\cf19  - \cf24 1\cf19 ) / \cf22 MemoryLayout\cf19 <\cf22 SIMD4\cf19 <\cf22 Float\cf19 >>.\cf25 alignment\cf19  * \cf22 MemoryLayout\cf19 <\cf22 SIMD4\cf19 <\cf22 Float\cf19 >>.\cf25 alignment\cf19 \
                \cf26 memcpy\cf19 (buffer.\cf26 contents\cf19 ().\cf26 advanced\cf19 (\cf26 by\cf19 : offset), &data, \cf22 MemoryLayout\cf19 <\cf22 SIMD4\cf19 <\cf22 Float\cf19 >>.\cf25 size\cf19 )\
                offset += \cf22 MemoryLayout\cf19 <\cf22 SIMD4\cf19 <\cf22 Float\cf19 >>.\cf25 size\cf19 \
            
\f3\b \cf20 default
\f2\b0 \cf19 : \cf18 // we shouldn't be here\cf19 \
                
\f3\b \cf20 throw
\f2\b0 \cf19  \cf32 "Bad data type: \cf19 \\(dataType)\cf32 "\cf19 \
            \}\
        \}\
    \}\
\
    \cf18 // Print current uniforms values\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 printUniforms\cf19 () \{\
        \cf26 print\cf19 (\cf30 uniformsToString\cf19 ())\
    \}\
    \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 getUniformFloat4\cf19 ( \cf23 _\cf19  name: \cf22 String\cf19  ) -> \cf22 SIMD4\cf19 <\cf22 Float\cf19 >? \{\
        
\f3\b \cf20 guard
\f2\b0 \cf19  \cf29 parameterMap\cf19 [name] != 
\f3\b \cf20 nil
\f2\b0 \cf19  
\f3\b \cf20 else
\f2\b0 \cf19  \{\
            
\f3\b \cf20 return
\f2\b0 \cf19  
\f3\b \cf20 nil
\f2\b0 \cf19 \
        \}\
        
\f3\b \cf20 let
\f2\b0 \cf19  data = \cf29 float4dict\cf19 .\cf30 get\cf19 (name)\
        
\f3\b \cf20 return
\f2\b0 \cf19  data\
    \}\
\
    \cf18 // Convert uniforms to a string representation for debugging\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 uniformsToString\cf19 () -> \cf22 String\cf19  \{\
        
\f3\b \cf20 let
\f2\b0 \cf19  uniforms = \cf22 Array\cf19 (\cf29 indexMap\cf19 .\cf25 indices\cf19 ).\cf26 map\cf19  \{ i 
\f3\b \cf20 in
\f2\b0 \cf19 \
            
\f3\b \cf20 let
\f2\b0 \cf19  (key, dataType) = \cf29 indexMap\cf19 [i]\
            
\f3\b \cf20 switch
\f2\b0 \cf19  dataType \{\
            
\f3\b \cf20 case
\f2\b0 \cf19  \cf32 "float"\cf19 :\
                
\f3\b \cf20 let
\f2\b0 \cf19  data = \cf29 float4dict\cf19 .\cf30 getAsFloat\cf19 (key)\
                
\f3\b \cf20 return
\f2\b0 \cf19  \cf32 "\cf19 \\(key)\cf32 , \cf19 \\(data)\cf32 "\cf19 \
            
\f3\b \cf20 case
\f2\b0 \cf19  \cf32 "float2"\cf19 :\
                
\f3\b \cf20 let
\f2\b0 \cf19  data = \cf29 float4dict\cf19 .\cf30 getAsFloat2\cf19 (key)\
                
\f3\b \cf20 return
\f2\b0 \cf19  \cf32 "\cf19 \\(key)\cf32 , \cf19 \\(data.\cf25 x\cf19 )\cf32 , \cf19 \\(data.\cf25 y\cf19 )\cf32 "\cf19 \
            
\f3\b \cf20 case
\f2\b0 \cf19  \cf32 "float3"\cf19 :\
                
\f3\b \cf20 let
\f2\b0 \cf19  data = \cf29 float4dict\cf19 .\cf30 getAsFloat3\cf19 (key)\
                
\f3\b \cf20 return
\f2\b0 \cf19  \cf32 "\cf19 \\(key)\cf32 , \cf19 \\(data.\cf25 x\cf19 )\cf32 , \cf19 \\(data.\cf25 y\cf19 )\cf32 , \cf19 \\(data.\cf25 z\cf19 )\cf32 ,"\cf19 \
            
\f3\b \cf20 default
\f2\b0 \cf19 : \cf18 // Assuming default is "float4"\cf19 \
                
\f3\b \cf20 let
\f2\b0 \cf19  data = \cf29 float4dict\cf19 .\cf30 get\cf19 (key)\
                
\f3\b \cf20 return
\f2\b0 \cf19  \cf32 "\cf19 \\(key)\cf32 , \cf19 \\(data.\cf25 x\cf19 )\cf32 , \cf19 \\(data.\cf25 y\cf19 )\cf32 , \cf19 \\(data.\cf25 z\cf19 )\cf32 , \cf19 \\(data.\cf25 w\cf19 )\cf32 "\cf19 \
            \}\
        \}.\cf26 joined\cf19 (\cf26 separator\cf19 : \cf32 "\\n"\cf19 )\
\
        
\f3\b \cf20 return
\f2\b0 \cf19  uniforms\
    \}\
\
    \cf18 // Save uniforms to a file, checking if there's a need to prompt for a directory\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 saveUniformsToFile\cf19 () \{\
        
\f3\b \cf20 if
\f2\b0 \cf19 ( \cf29 indexMap\cf19 .\cf25 count\cf19  == \cf24 0\cf19  ) \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
\
        
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  fileUrl = \cf29 uniformsTxtURL\cf19  
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
        
\f3\b \cf20 let
\f2\b0 \cf19  uniforms = \cf30 uniformsToString\cf19 ()\
\
        
\f3\b \cf20 let
\f2\b0 \cf19  bookmarkData = \cf31 UserDefaults\cf19 .\cf25 standard\cf19 .\cf26 data\cf19 (\cf26 forKey\cf19 : \cf32 "bookmark_\cf19 \\(\cf29 bookmarkID\cf19 )\cf32 "\cf19 )\
        
\f3\b \cf20 if
\f2\b0 \cf19 ( bookmarkData == 
\f3\b \cf20 nil
\f2\b0 \cf19  ) \{\
            \cf26 print\cf19 (\cf32 "no bookmark"\cf19 )\
        \}\
\
        \cf18 // Accessing the bookmark to perform file operations\cf19 \
        \cf30 accessBookmarkedDirectory\cf19 (\cf30 withIdentifier\cf19 : \cf29 bookmarkID\cf19 ) \{ dirUrl 
\f3\b \cf20 in
\f2\b0 \cf19 \
            
\f3\b \cf20 do
\f2\b0 \cf19  \{\
                
\f3\b \cf20 try
\f2\b0 \cf19  uniforms.\cf26 write\cf19 (\cf26 to\cf19 : fileUrl, \cf26 atomically\cf19 : 
\f3\b \cf20 true
\f2\b0 \cf19 , \cf26 encoding\cf19 : .\cf25 utf8\cf19 )\
                \cf26 print\cf19 (\cf32 "Data written successfully to \cf19 \\(fileUrl.\cf25 path\cf19 )\cf32 "\cf19 )\
            \} 
\f3\b \cf20 catch
\f2\b0 \cf19  \{\
                \cf26 print\cf19 (\cf32 "Failed to save uniforms: \cf19 \\(error)\cf32 "\cf19 )\
            \}\
        \}\
\
    \}\
\
    \cf18 // Load uniforms from a file\cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 loadUniformsFromFile\cf19 () \{\
        
\f3\b \cf20 let
\f2\b0 \cf19  path = \cf29 uniformsTxtURL\cf19 \
        
\f3\b \cf20 guard
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  filePath = path 
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \}\
\
        
\f3\b \cf20 do
\f2\b0 \cf19  \{\
            
\f3\b \cf20 let
\f2\b0 \cf19  content = 
\f3\b \cf20 try
\f2\b0 \cf19  \cf22 String\cf19 (\cf26 contentsOf\cf19 : filePath, \cf26 encoding\cf19 : .\cf25 utf8\cf19 )\
            
\f3\b \cf20 let
\f2\b0 \cf19  lines = content.\cf26 split\cf19 (\cf26 separator\cf19 : \cf32 "\\n"\cf19 )\
            
\f3\b \cf20 var
\f2\b0 \cf19  data:[(\cf22 String\cf19 ,\cf22 String\cf19 ,[\cf22 Float\cf19 ])] = []\
            
\f3\b \cf20 for
\f2\b0 \cf19  line 
\f3\b \cf20 in
\f2\b0 \cf19  lines \{\
                
\f3\b \cf20 var
\f2\b0 \cf19  segs = line.\cf26 split\cf19 (\cf26 separator\cf19 : \cf32 ","\cf19 )\
                segs = segs.\cf26 map\cf19  \{ seg 
\f3\b \cf20 in
\f2\b0 \cf19  seg.\cf26 filter\cf19  \{ !$0.\cf25 isWhitespace\cf19  \} \}\
                
\f3\b \cf20 var
\f2\b0 \cf19  dataType=\cf32 ""\cf19 \
                
\f3\b \cf20 switch
\f2\b0 \cf19  segs.\cf25 count\cf19  \{\
                
\f3\b \cf20 case
\f2\b0 \cf19  \cf24 2\cf19 : dataType=\cf32 "float"\cf19 \
                
\f3\b \cf20 case
\f2\b0 \cf19  \cf24 3\cf19 : dataType=\cf32 "float2"\cf19 \
                
\f3\b \cf20 case
\f2\b0 \cf19  \cf24 4\cf19 : dataType=\cf32 "float3"\cf19 \
                
\f3\b \cf20 case
\f2\b0 \cf19  \cf24 5\cf19 : dataType=\cf32 "float4"\cf19 \
                
\f3\b \cf20 default
\f2\b0 \cf19 : 
\f3\b \cf20 throw
\f2\b0 \cf19  \cf32 "invalid line: \cf19 \\(line)\cf32 "\cf19 \
                \}\
                
\f3\b \cf20 let
\f2\b0 \cf19  name = \cf22 String\cf19 (segs[\cf24 0\cf19 ])\
                
\f3\b \cf20 let
\f2\b0 \cf19  floats = 
\f3\b \cf20 try
\f2\b0 \cf19  segs[\cf24 1\cf19 ...].\cf26 map\cf19  \{ s 
\f3\b \cf20 in
\f2\b0 \cf19 \
                    
\f3\b \cf20 let
\f2\b0 \cf19  float = \cf22 Float\cf19 (s)\
                    
\f3\b \cf20 if
\f2\b0 \cf19 ( float == 
\f3\b \cf20 nil
\f2\b0 \cf19  ) \{ 
\f3\b \cf20 throw
\f2\b0 \cf19  \cf32 "invalid line: \cf19 \\(line)\cf32 "\cf19  \}\
                    
\f3\b \cf20 return
\f2\b0 \cf19  float!\
                \}\
                data.\cf26 append\cf19 ((name, dataType, floats))\
            \}\
\
            
\f3\b \cf20 for
\f2\b0 \cf19  (name, _, floats) 
\f3\b \cf20 in
\f2\b0 \cf19  data \{\
                \cf30 setUniformTuple\cf19 (name,\cf30 values\cf19 : floats, \cf30 suppressSave\cf19 : 
\f3\b \cf20 true
\f2\b0 \cf19 )\
            \}\
            \cf26 print\cf19 (\cf32 "Uniforms successfully loaded from file."\cf19 )\
\
        \} 
\f3\b \cf20 catch
\f2\b0 \cf19  \{\
            \cf26 print\cf19 (\cf32 "Failed to read the \cf19 \\(\cf29 uniformsTxtURL\cf19 ?.\cf26 path\cf19 (\cf26 percentEncoded\cf19 : 
\f3\b \cf20 false
\f2\b0 \cf19 ) ?? \cf32 ""\cf19 )\cf32  file: \cf19 \\(error)\cf32 "\cf19 )\
        \}\
    \}\
\
    \cf18 // Get the shader source from a URL and parse it for uniform struct definitions\cf19 \
    
\f3\b \cf20 private
\f2\b0 \cf19  
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 getShaderSource\cf19 (\cf23 srcURL\cf19 : \cf22 URL\cf19 ) -> \cf22 String\cf19 ?\
    \{\
        
\f3\b \cf20 let
\f2\b0 \cf19  command = \cf32 "cpp \cf19 \\(srcURL.\cf25 path\cf19 )\cf32  2> /dev/null | cat"\cf19  \cf18 // hack to avoid error status on cpp\cf19 \
        
\f3\b \cf20 let
\f2\b0 \cf19  execResult = \cf30 shell_exec\cf19 (command, \cf30 cwd\cf19 : 
\f3\b \cf20 nil
\f2\b0 \cf19 )\
        
\f3\b \cf20 if
\f2\b0 \cf19  execResult.\cf29 exitCode\cf19  != \cf24 0\cf19  \{\
            
\f3\b \cf20 return
\f2\b0 \cf19  
\f3\b \cf20 nil
\f2\b0 \cf19 \
        \}\
        
\f3\b \cf20 return
\f2\b0 \cf19  execResult.\cf29 stdOut\cf19 \
    \}\
\
    \cf18 // parses the shader file to look for a struct tagged\cf19 \
    \cf18 // with @uniform, which will define which uniforms\cf19 \
    \cf18 // are managed by the application and sent to the fragment\cf19 \
    \cf18 // shader in a buffer.  Example struct in fragment.metal:\cf19 \
    \cf18 //\cf19 \
    \cf18 //    struct MyShaderData \{ // @uniform\cf19 \
    \cf18 //        float2 o_long;\cf19 \
    \cf18 //        float4 o_pan;\cf19 \
    \cf18 //        float o_col1r;\cf19 \
    \cf18 //    \}\cf19 \
    \cf18 //\cf19 \
    \cf18 // 
\f3\b \cf33 TODO: improve documentation.  Add unit tests.  Add type checking (vectors only)
\f2\b0 \cf19 \
    
\f3\b \cf20 func
\f2\b0 \cf19  \cf23 setupUniformsFromShader\cf19 (\cf23 metalDevice\cf19 : \cf31 MTLDevice\cf19 , \cf23 srcURL\cf19 : \cf22 URL\cf19 ) -> \cf22 String\cf19 ?\
    \{\
        \cf30 resetMapping\cf19 ()\
        \cf29 semaphore\cf19 .\cf26 wait\cf19 ()\
        
\f3\b \cf20 defer
\f2\b0 \cf19  \{ \cf29 semaphore\cf19 .\cf26 signal\cf19 () \}\
        
\f3\b \cf20 guard
\f2\b0 \cf19 \
            
\f3\b \cf20 let
\f2\b0 \cf19  shaderSource = \cf30 getShaderSource\cf19 (\cf30 srcURL\cf19 : srcURL)\
            
\f3\b \cf20 else
\f2\b0 \cf19  \{ 
\f3\b \cf20 return
\f2\b0 \cf19  \cf32 "Failed to read shader file: \cf19 \\(srcURL)\cf32 "\cf19  \}\
\
        
\f3\b \cf20 let
\f2\b0 \cf19  lines = shaderSource.\cf26 components\cf19 (\cf26 separatedBy\cf19 : \cf32 "\\n"\cf19 )\
\
        
\f3\b \cf20 let
\f2\b0 \cf19  structRegex = \cf32 /\cf19 \\s*\cf32 struct\cf19 \\s+(\\w+)\\s*\\\cf32 \{\cf19 \\s*\\\cf32 /\cf19 \\\cf32 /\cf19 \\s*\cf32 @uniform/\cf19 \
        
\f3\b \cf20 let
\f2\b0 \cf19  endStructRegex = \cf32 /\cf19 \\s*\\\cf32 \}\cf19 \\\cf32 ;/\cf19 \
        
\f3\b \cf20 let
\f2\b0 \cf19  metadataRegex = \cf32 /\cf19 \\s?(\cf32 float\cf19 \\d?)\\s+(\\w+)\cf32 /\cf19 \
\
        
\f3\b \cf20 var
\f2\b0 \cf19  index = \cf24 0\cf19 \
        
\f3\b \cf20 var
\f2\b0 \cf19  insideStruct = 
\f3\b \cf20 false
\f2\b0 \cf19 \
        
\f3\b \cf20 for
\f2\b0 \cf19  line 
\f3\b \cf20 in
\f2\b0 \cf19  lines \{\
            
\f3\b \cf20 if
\f2\b0 \cf19 ( insideStruct ) \{\
                
\f3\b \cf20 if
\f2\b0 \cf19  
\f3\b \cf20 let
\f2\b0 \cf19  firstMatch = line.\cf26 firstMatch\cf19 (\cf26 of\cf19 : metadataRegex) \{\
                    index = \cf30 setIndex\cf19 (\cf30 name\cf19 : \cf22 String\cf19 (firstMatch.\cf24 2\cf19 ), \cf30 type\cf19 : \cf22 String\cf19 (firstMatch.\cf24 1\cf19 ))\
                \}\
                
\f3\b \cf20 if
\f2\b0 \cf19 ( line.\cf26 firstMatch\cf19 (\cf26 of\cf19 : endStructRegex) != 
\f3\b \cf20 nil
\f2\b0 \cf19  ) \{\
                    
\f3\b \cf20 break
\f2\b0 \cf19 \
                \}\
            \}\
            
\f3\b \cf20 if
\f2\b0 \cf19 ( line.\cf26 firstMatch\cf19 (\cf26 of\cf19 : structRegex) != 
\f3\b \cf20 nil
\f2\b0 \cf19  ) \{ insideStruct = 
\f3\b \cf20 true
\f2\b0 \cf19  \}\
        \}\
        
\f3\b \cf20 let
\f2\b0 \cf19  numUniforms = index + \cf24 1\cf19 \
        
\f3\b \cf20 let
\f2\b0 \cf19  length = \cf22 MemoryLayout\cf19 <\cf22 SIMD4\cf19 <\cf22 Float\cf19 >>.\cf25 size\cf19 *numUniforms\
        \cf29 buffer\cf19  = metalDevice.\cf26 makeBuffer\cf19 (\cf26 length\cf19 : length, \cf26 options\cf19 : .\cf25 storageModeShared\cf19 )\
        \cf29 dirty\cf19  = 
\f3\b \cf20 true
\f2\b0 \cf19 \
\
        
\f3\b \cf20 if
\f2\b0 \cf19 ( \cf29 debug\cf19  ) \{\
            \cf30 printUniforms\cf19 ()\
        \}\
        \cf29 uniformsTxtURL\cf19  = srcURL.\cf26 deletingPathExtension\cf19 ().\cf26 appendingPathExtension\cf19 (\cf32 "uniforms"\cf19 ).\cf26 appendingPathExtension\cf19 (\cf32 "txt"\cf19 )\
        \cf29 uniformsTxtURL\cf19  = \cf22 URL\cf19 (\cf26 fileURLWithPath\cf19 : \cf29 uniformsTxtURL\cf19 !.\cf25 path\cf19 )\
        
\f3\b \cf20 let
\f2\b0 \cf19  bookmarkData = \cf31 UserDefaults\cf19 .\cf25 standard\cf19 .\cf26 data\cf19 (\cf26 forKey\cf19 : \cf32 "bookmark_\cf19 \\(\cf29 bookmarkID\cf19 )\cf32 "\cf19 )\
        
\f3\b \cf20 if
\f2\b0 \cf19 ( bookmarkData == 
\f3\b \cf20 nil
\f2\b0 \cf19  ) \{\
            \cf26 print\cf19 (\cf32 "WARNING: no project directory bookmark found"\cf19 )\
            \cf30 selectDirectory\cf19 ()\
        \}\
        \cf30 loadUniformsFromFile\cf19 ()\
        
\f3\b \cf20 return
\f2\b0 \cf19  
\f3\b \cf20 nil
\f2\b0 \cf19 \
    \}\
\}\
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf34 \cb35 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec36 \
}